<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1">
<link rel="stylesheet" href="github-markdown.css">
<style>
@font-face {
  font-family: octicons-link;
  src: url(data:font/woff;charset=utf-8;base64,d09GRgABAAAAAAZwABAAAAAACFQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAABEU0lHAAAGaAAAAAgAAAAIAAAAAUdTVUIAAAZcAAAACgAAAAoAAQAAT1MvMgAAAyQAAABJAAAAYFYEU3RjbWFwAAADcAAAAEUAAACAAJThvmN2dCAAAATkAAAABAAAAAQAAAAAZnBnbQAAA7gAAACyAAABCUM+8IhnYXNwAAAGTAAAABAAAAAQABoAI2dseWYAAAFsAAABPAAAAZwcEq9taGVhZAAAAsgAAAA0AAAANgh4a91oaGVhAAADCAAAABoAAAAkCA8DRGhtdHgAAAL8AAAADAAAAAwGAACfbG9jYQAAAsAAAAAIAAAACABiATBtYXhwAAACqAAAABgAAAAgAA8ASm5hbWUAAAToAAABQgAAAlXu73sOcG9zdAAABiwAAAAeAAAAME3QpOBwcmVwAAAEbAAAAHYAAAB/aFGpk3jaTY6xa8JAGMW/O62BDi0tJLYQincXEypYIiGJjSgHniQ6umTsUEyLm5BV6NDBP8Tpts6F0v+k/0an2i+itHDw3v2+9+DBKTzsJNnWJNTgHEy4BgG3EMI9DCEDOGEXzDADU5hBKMIgNPZqoD3SilVaXZCER3/I7AtxEJLtzzuZfI+VVkprxTlXShWKb3TBecG11rwoNlmmn1P2WYcJczl32etSpKnziC7lQyWe1smVPy/Lt7Kc+0vWY/gAgIIEqAN9we0pwKXreiMasxvabDQMM4riO+qxM2ogwDGOZTXxwxDiycQIcoYFBLj5K3EIaSctAq2kTYiw+ymhce7vwM9jSqO8JyVd5RH9gyTt2+J/yUmYlIR0s04n6+7Vm1ozezUeLEaUjhaDSuXHwVRgvLJn1tQ7xiuVv/ocTRF42mNgZGBgYGbwZOBiAAFGJBIMAAizAFoAAABiAGIAznjaY2BkYGAA4in8zwXi+W2+MjCzMIDApSwvXzC97Z4Ig8N/BxYGZgcgl52BCSQKAA3jCV8CAABfAAAAAAQAAEB42mNgZGBg4f3vACQZQABIMjKgAmYAKEgBXgAAeNpjYGY6wTiBgZWBg2kmUxoDA4MPhGZMYzBi1AHygVLYQUCaawqDA4PChxhmh/8ODDEsvAwHgMKMIDnGL0x7gJQCAwMAJd4MFwAAAHjaY2BgYGaA4DAGRgYQkAHyGMF8NgYrIM3JIAGVYYDT+AEjAwuDFpBmA9KMDEwMCh9i/v8H8sH0/4dQc1iAmAkALaUKLgAAAHjaTY9LDsIgEIbtgqHUPpDi3gPoBVyRTmTddOmqTXThEXqrob2gQ1FjwpDvfwCBdmdXC5AVKFu3e5MfNFJ29KTQT48Ob9/lqYwOGZxeUelN2U2R6+cArgtCJpauW7UQBqnFkUsjAY/kOU1cP+DAgvxwn1chZDwUbd6CFimGXwzwF6tPbFIcjEl+vvmM/byA48e6tWrKArm4ZJlCbdsrxksL1AwWn/yBSJKpYbq8AXaaTb8AAHja28jAwOC00ZrBeQNDQOWO//sdBBgYGRiYWYAEELEwMTE4uzo5Zzo5b2BxdnFOcALxNjA6b2ByTswC8jYwg0VlNuoCTWAMqNzMzsoK1rEhNqByEyerg5PMJlYuVueETKcd/89uBpnpvIEVomeHLoMsAAe1Id4AAAAAAAB42oWQT07CQBTGv0JBhagk7HQzKxca2sJCE1hDt4QF+9JOS0nbaaYDCQfwCJ7Au3AHj+LO13FMmm6cl7785vven0kBjHCBhfpYuNa5Ph1c0e2Xu3jEvWG7UdPDLZ4N92nOm+EBXuAbHmIMSRMs+4aUEd4Nd3CHD8NdvOLTsA2GL8M9PODbcL+hD7C1xoaHeLJSEao0FEW14ckxC+TU8TxvsY6X0eLPmRhry2WVioLpkrbp84LLQPGI7c6sOiUzpWIWS5GzlSgUzzLBSikOPFTOXqly7rqx0Z1Q5BAIoZBSFihQYQOOBEdkCOgXTOHA07HAGjGWiIjaPZNW13/+lm6S9FT7rLHFJ6fQbkATOG1j2OFMucKJJsxIVfQORl+9Jyda6Sl1dUYhSCm1dyClfoeDve4qMYdLEbfqHf3O/AdDumsjAAB42mNgYoAAZQYjBmyAGYQZmdhL8zLdDEydARfoAqIAAAABAAMABwAKABMAB///AA8AAQAAAAAAAAAAAAAAAAABAAAAAA==) format('woff');
}

.markdown-body .octicon {
  display: inline-block;
  fill: currentColor;
  vertical-align: text-bottom;
}

.markdown-body .anchor {
  float: left;
  line-height: 1;
  margin-left: -20px;
  padding-right: 4px;
}

.markdown-body .anchor:focus {
  outline: none;
}

.markdown-body h1 .octicon-link,
.markdown-body h2 .octicon-link,
.markdown-body h3 .octicon-link,
.markdown-body h4 .octicon-link,
.markdown-body h5 .octicon-link,
.markdown-body h6 .octicon-link {
  color: #1b1f23;
  vertical-align: middle;
  visibility: hidden;
}

.markdown-body h1:hover .anchor,
.markdown-body h2:hover .anchor,
.markdown-body h3:hover .anchor,
.markdown-body h4:hover .anchor,
.markdown-body h5:hover .anchor,
.markdown-body h6:hover .anchor {
  text-decoration: none;
}

.markdown-body h1:hover .anchor .octicon-link,
.markdown-body h2:hover .anchor .octicon-link,
.markdown-body h3:hover .anchor .octicon-link,
.markdown-body h4:hover .anchor .octicon-link,
.markdown-body h5:hover .anchor .octicon-link,
.markdown-body h6:hover .anchor .octicon-link {
  visibility: visible;
}

.markdown-body {
  -ms-text-size-adjust: 100%;
  -webkit-text-size-adjust: 100%;
  color: #24292e;
  line-height: 1.5;
  font-family: -apple-system,BlinkMacSystemFont,Segoe UI,Helvetica,Arial,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol;
  font-size: 16px;
  line-height: 1.5;
  word-wrap: break-word;
}

.markdown-body .pl-c {
  color: #6a737d;
}

.markdown-body .pl-c1,
.markdown-body .pl-s .pl-v {
  color: #005cc5;
}

.markdown-body .pl-e,
.markdown-body .pl-en {
  color: #6f42c1;
}

.markdown-body .pl-s .pl-s1,
.markdown-body .pl-smi {
  color: #24292e;
}

.markdown-body .pl-ent {
  color: #22863a;
}

.markdown-body .pl-k {
  color: #d73a49;
}

.markdown-body .pl-pds,
.markdown-body .pl-s,
.markdown-body .pl-s .pl-pse .pl-s1,
.markdown-body .pl-sr,
.markdown-body .pl-sr .pl-cce,
.markdown-body .pl-sr .pl-sra,
.markdown-body .pl-sr .pl-sre {
  color: #032f62;
}

.markdown-body .pl-smw,
.markdown-body .pl-v {
  color: #e36209;
}

.markdown-body .pl-bu {
  color: #b31d28;
}

.markdown-body .pl-ii {
  background-color: #b31d28;
  color: #fafbfc;
}

.markdown-body .pl-c2 {
  background-color: #d73a49;
  color: #fafbfc;
}

.markdown-body .pl-c2:before {
  content: "^M";
}

.markdown-body .pl-sr .pl-cce {
  color: #22863a;
  font-weight: 700;
}

.markdown-body .pl-ml {
  color: #735c0f;
}

.markdown-body .pl-mh,
.markdown-body .pl-mh .pl-en,
.markdown-body .pl-ms {
  color: #005cc5;
  font-weight: 700;
}

.markdown-body .pl-mi {
  color: #24292e;
  font-style: italic;
}

.markdown-body .pl-mb {
  color: #24292e;
  font-weight: 700;
}

.markdown-body .pl-md {
  background-color: #ffeef0;
  color: #b31d28;
}

.markdown-body .pl-mi1 {
  background-color: #f0fff4;
  color: #22863a;
}

.markdown-body .pl-mc {
  background-color: #ffebda;
  color: #e36209;
}

.markdown-body .pl-mi2 {
  background-color: #005cc5;
  color: #f6f8fa;
}

.markdown-body .pl-mdr {
  color: #6f42c1;
  font-weight: 700;
}

.markdown-body .pl-ba {
  color: #586069;
}

.markdown-body .pl-sg {
  color: #959da5;
}

.markdown-body .pl-corl {
  color: #032f62;
  text-decoration: underline;
}

.markdown-body details {
  display: block;
}

.markdown-body summary {
  display: list-item;
}

.markdown-body a {
  background-color: transparent;
}

.markdown-body a:active,
.markdown-body a:hover {
  outline-width: 0;
}

.markdown-body strong {
  font-weight: inherit;
  font-weight: bolder;
}

.markdown-body h1 {
  font-size: 2em;
  margin: .67em 0;
}

.markdown-body img {
  border-style: none;
}

.markdown-body code,
.markdown-body kbd,
.markdown-body pre {
  font-family: monospace,monospace;
  font-size: 1em;
}

.markdown-body hr {
  box-sizing: content-box;
  height: 0;
  overflow: visible;
}

.markdown-body input {
  font: inherit;
  margin: 0;
}

.markdown-body input {
  overflow: visible;
}

.markdown-body [type=checkbox] {
  box-sizing: border-box;
  padding: 0;
}

.markdown-body * {
  box-sizing: border-box;
}

.markdown-body input {
  font-family: inherit;
  font-size: inherit;
  line-height: inherit;
}

.markdown-body a {
  color: #0366d6;
  text-decoration: none;
}

.markdown-body a:hover {
  text-decoration: underline;
}

.markdown-body strong {
  font-weight: 600;
}

.markdown-body hr {
  background: transparent;
  border: 0;
  border-bottom: 1px solid #dfe2e5;
  height: 0;
  margin: 15px 0;
  overflow: hidden;
}

.markdown-body hr:before {
  content: "";
  display: table;
}

.markdown-body hr:after {
  clear: both;
  content: "";
  display: table;
}

.markdown-body table {
  border-collapse: collapse;
  border-spacing: 0;
}

.markdown-body td,
.markdown-body th {
  padding: 0;
}

.markdown-body details summary {
  cursor: pointer;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body h1 {
  font-size: 32px;
}

.markdown-body h1,
.markdown-body h2 {
  font-weight: 600;
}

.markdown-body h2 {
  font-size: 24px;
}

.markdown-body h3 {
  font-size: 20px;
}

.markdown-body h3,
.markdown-body h4 {
  font-weight: 600;
}

.markdown-body h4 {
  font-size: 16px;
}

.markdown-body h5 {
  font-size: 14px;
}

.markdown-body h5,
.markdown-body h6 {
  font-weight: 600;
}

.markdown-body h6 {
  font-size: 12px;
}

.markdown-body p {
  margin-bottom: 10px;
  margin-top: 0;
}

.markdown-body blockquote {
  margin: 0;
}

.markdown-body ol,
.markdown-body ul {
  margin-bottom: 0;
  margin-top: 0;
  padding-left: 0;
}

.markdown-body ol ol,
.markdown-body ul ol {
  list-style-type: lower-roman;
}

.markdown-body ol ol ol,
.markdown-body ol ul ol,
.markdown-body ul ol ol,
.markdown-body ul ul ol {
  list-style-type: lower-alpha;
}

.markdown-body dd {
  margin-left: 0;
}

.markdown-body code,
.markdown-body pre {
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
}

.markdown-body pre {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body input::-webkit-inner-spin-button,
.markdown-body input::-webkit-outer-spin-button {
  -webkit-appearance: none;
  appearance: none;
  margin: 0;
}

.markdown-body .border {
  border: 1px solid #e1e4e8!important;
}

.markdown-body .border-0 {
  border: 0!important;
}

.markdown-body .border-bottom {
  border-bottom: 1px solid #e1e4e8!important;
}

.markdown-body .rounded-1 {
  border-radius: 3px!important;
}

.markdown-body .bg-white {
  background-color: #fff!important;
}

.markdown-body .bg-gray-light {
  background-color: #fafbfc!important;
}

.markdown-body .text-gray-light {
  color: #6a737d!important;
}

.markdown-body .mb-0 {
  margin-bottom: 0!important;
}

.markdown-body .my-2 {
  margin-bottom: 8px!important;
  margin-top: 8px!important;
}

.markdown-body .pl-0 {
  padding-left: 0!important;
}

.markdown-body .py-0 {
  padding-bottom: 0!important;
  padding-top: 0!important;
}

.markdown-body .pl-1 {
  padding-left: 4px!important;
}

.markdown-body .pl-2 {
  padding-left: 8px!important;
}

.markdown-body .py-2 {
  padding-bottom: 8px!important;
  padding-top: 8px!important;
}

.markdown-body .pl-3,
.markdown-body .px-3 {
  padding-left: 16px!important;
}

.markdown-body .px-3 {
  padding-right: 16px!important;
}

.markdown-body .pl-4 {
  padding-left: 24px!important;
}

.markdown-body .pl-5 {
  padding-left: 32px!important;
}

.markdown-body .pl-6 {
  padding-left: 40px!important;
}

.markdown-body .f6 {
  font-size: 12px!important;
}

.markdown-body .lh-condensed {
  line-height: 1.25!important;
}

.markdown-body .text-bold {
  font-weight: 600!important;
}

.markdown-body:before {
  content: "";
  display: table;
}

.markdown-body:after {
  clear: both;
  content: "";
  display: table;
}

.markdown-body>:first-child {
  margin-top: 0!important;
}

.markdown-body>:last-child {
  margin-bottom: 0!important;
}

.markdown-body a:not([href]) {
  color: inherit;
  text-decoration: none;
}

.markdown-body blockquote,
.markdown-body dl,
.markdown-body ol,
.markdown-body p,
.markdown-body pre,
.markdown-body table,
.markdown-body ul {
  margin-bottom: 16px;
  margin-top: 0;
}

.markdown-body hr {
  background-color: #e1e4e8;
  border: 0;
  height: .25em;
  margin: 24px 0;
  padding: 0;
}

.markdown-body blockquote {
  border-left: .25em solid #dfe2e5;
  color: #6a737d;
  padding: 0 1em;
}

.markdown-body blockquote>:first-child {
  margin-top: 0;
}

.markdown-body blockquote>:last-child {
  margin-bottom: 0;
}

.markdown-body kbd {
  background-color: #fafbfc;
  border: 1px solid #c6cbd1;
  border-bottom-color: #959da5;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #959da5;
  color: #444d56;
  display: inline-block;
  font-size: 11px;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

.markdown-body h1,
.markdown-body h2,
.markdown-body h3,
.markdown-body h4,
.markdown-body h5,
.markdown-body h6 {
  font-weight: 600;
  line-height: 1.25;
  margin-bottom: 16px;
  margin-top: 24px;
}

.markdown-body h1 {
  font-size: 2em;
}

.markdown-body h1,
.markdown-body h2 {
  border-bottom: 1px solid #eaecef;
  padding-bottom: .3em;
}

.markdown-body h2 {
  font-size: 1.5em;
}

.markdown-body h3 {
  font-size: 1.25em;
}

.markdown-body h4 {
  font-size: 1em;
}

.markdown-body h5 {
  font-size: .875em;
}

.markdown-body h6 {
  color: #6a737d;
  font-size: .85em;
}

.markdown-body ol,
.markdown-body ul {
  padding-left: 2em;
}

.markdown-body ol ol,
.markdown-body ol ul,
.markdown-body ul ol,
.markdown-body ul ul {
  margin-bottom: 0;
  margin-top: 0;
}

.markdown-body li {
  word-wrap: break-all;
}

.markdown-body li>p {
  margin-top: 16px;
}

.markdown-body li+li {
  margin-top: .25em;
}

.markdown-body dl {
  padding: 0;
}

.markdown-body dl dt {
  font-size: 1em;
  font-style: italic;
  font-weight: 600;
  margin-top: 16px;
  padding: 0;
}

.markdown-body dl dd {
  margin-bottom: 16px;
  padding: 0 16px;
}

.markdown-body table {
  display: block;
  overflow: auto;
  width: 100%;
}

.markdown-body table th {
  font-weight: 600;
}

.markdown-body table td,
.markdown-body table th {
  border: 1px solid #dfe2e5;
  padding: 6px 13px;
}

.markdown-body table tr {
  background-color: #fff;
  border-top: 1px solid #c6cbd1;
}

.markdown-body table tr:nth-child(2n) {
  background-color: #f6f8fa;
}

.markdown-body img {
  background-color: #fff;
  box-sizing: content-box;
  max-width: 100%;
}

.markdown-body img[align=right] {
  padding-left: 20px;
}

.markdown-body img[align=left] {
  padding-right: 20px;
}

.markdown-body code {
  background-color: rgba(27,31,35,.05);
  border-radius: 3px;
  font-size: 85%;
  margin: 0;
  padding: .2em .4em;
}

.markdown-body pre {
  word-wrap: normal;
}

.markdown-body pre>code {
  background: transparent;
  border: 0;
  font-size: 100%;
  margin: 0;
  padding: 0;
  white-space: pre;
  word-break: normal;
}

.markdown-body .highlight {
  margin-bottom: 16px;
}

.markdown-body .highlight pre {
  margin-bottom: 0;
  word-break: normal;
}

.markdown-body .highlight pre,
.markdown-body pre {
  background-color: #f6f8fa;
  border-radius: 3px;
  font-size: 85%;
  line-height: 1.45;
  overflow: auto;
  padding: 16px;
}

.markdown-body pre code {
  background-color: transparent;
  border: 0;
  display: inline;
  line-height: inherit;
  margin: 0;
  max-width: auto;
  overflow: visible;
  padding: 0;
  word-wrap: normal;
}

.markdown-body .commit-tease-sha {
  color: #444d56;
  display: inline-block;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 90%;
}

.markdown-body .blob-wrapper {
  border-bottom-left-radius: 3px;
  border-bottom-right-radius: 3px;
  overflow-x: auto;
  overflow-y: hidden;
}

.markdown-body .blob-wrapper-embedded {
  max-height: 240px;
  overflow-y: auto;
}

.markdown-body .blob-num {
  -moz-user-select: none;
  -ms-user-select: none;
  -webkit-user-select: none;
  color: rgba(27,31,35,.3);
  cursor: pointer;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
  line-height: 20px;
  min-width: 50px;
  padding-left: 10px;
  padding-right: 10px;
  text-align: right;
  user-select: none;
  vertical-align: top;
  white-space: nowrap;
  width: 1%;
}

.markdown-body .blob-num:hover {
  color: rgba(27,31,35,.6);
}

.markdown-body .blob-num:before {
  content: attr(data-line-number);
}

.markdown-body .blob-code {
  line-height: 20px;
  padding-left: 10px;
  padding-right: 10px;
  position: relative;
  vertical-align: top;
}

.markdown-body .blob-code-inner {
  color: #24292e;
  font-family: SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  font-size: 12px;
  overflow: visible;
  white-space: pre;
  word-wrap: normal;
}

.markdown-body .pl-token.active,
.markdown-body .pl-token:hover {
  background: #ffea7f;
  cursor: pointer;
}

.markdown-body kbd {
  background-color: #fafbfc;
  border: 1px solid #d1d5da;
  border-bottom-color: #c6cbd1;
  border-radius: 3px;
  box-shadow: inset 0 -1px 0 #c6cbd1;
  color: #444d56;
  display: inline-block;
  font: 11px SFMono-Regular,Consolas,Liberation Mono,Menlo,Courier,monospace;
  line-height: 10px;
  padding: 3px 5px;
  vertical-align: middle;
}

.markdown-body :checked+.radio-label {
  border-color: #0366d6;
  position: relative;
  z-index: 1;
}

.markdown-body .tab-size[data-tab-size="1"] {
  -moz-tab-size: 1;
  tab-size: 1;
}

.markdown-body .tab-size[data-tab-size="2"] {
  -moz-tab-size: 2;
  tab-size: 2;
}

.markdown-body .tab-size[data-tab-size="3"] {
  -moz-tab-size: 3;
  tab-size: 3;
}

.markdown-body .tab-size[data-tab-size="4"] {
  -moz-tab-size: 4;
  tab-size: 4;
}

.markdown-body .tab-size[data-tab-size="5"] {
  -moz-tab-size: 5;
  tab-size: 5;
}

.markdown-body .tab-size[data-tab-size="6"] {
  -moz-tab-size: 6;
  tab-size: 6;
}

.markdown-body .tab-size[data-tab-size="7"] {
  -moz-tab-size: 7;
  tab-size: 7;
}

.markdown-body .tab-size[data-tab-size="8"] {
  -moz-tab-size: 8;
  tab-size: 8;
}

.markdown-body .tab-size[data-tab-size="9"] {
  -moz-tab-size: 9;
  tab-size: 9;
}

.markdown-body .tab-size[data-tab-size="10"] {
  -moz-tab-size: 10;
  tab-size: 10;
}

.markdown-body .tab-size[data-tab-size="11"] {
  -moz-tab-size: 11;
  tab-size: 11;
}

.markdown-body .tab-size[data-tab-size="12"] {
  -moz-tab-size: 12;
  tab-size: 12;
}

.markdown-body .task-list-item {
  list-style-type: none;
}

.markdown-body .task-list-item+.task-list-item {
  margin-top: 3px;
}

.markdown-body .task-list-item input {
  margin: 0 .2em .25em -1.6em;
  vertical-align: middle;
}

.markdown-body hr {
  border-bottom-color: #eee;
}

.markdown-body .pl-0 {
  padding-left: 0!important;
}

.markdown-body .pl-1 {
  padding-left: 4px!important;
}

.markdown-body .pl-2 {
  padding-left: 8px!important;
}

.markdown-body .pl-3 {
  padding-left: 16px!important;
}

.markdown-body .pl-4 {
  padding-left: 24px!important;
}

.markdown-body .pl-5 {
  padding-left: 32px!important;
}

.markdown-body .pl-6 {
  padding-left: 40px!important;
}

.markdown-body .pl-7 {
  padding-left: 48px!important;
}

.markdown-body .pl-8 {
  padding-left: 64px!important;
}

.markdown-body .pl-9 {
  padding-left: 80px!important;
}

.markdown-body .pl-10 {
  padding-left: 96px!important;
}

.markdown-body .pl-11 {
  padding-left: 112px!important;
}

.markdown-body .pl-12 {
  padding-left: 128px!important;
}
</style>
<style>
 .markdown-body {
  box-sizing: border-box;
  min-width: 200px;
  max-width: 980px;
  margin: 0 auto;
  padding: 45px;
 }

 @media (max-width: 767px) {
  .markdown-body {
   padding: 15px;
  }
 }
</style>
</head>
<body>
<article class="markdown-body">
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c1"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>M_system(3fm)</b> - [M_system::INTRO] Fortran interface to C system interface <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="11"></a>

      <h3><a name="11">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
<b>Public</b> objects:
<br />   ! ENVIRONMENT
   use m_system, only : set_environment_variable, system_unsetenv, &amp;
   system_putenv, system_getenv
<br />   use m_system, only :  system_intenv, system_readenv, system_clearenv
   ! FILE SYSTEM
   use M_system, only : system_getcwd, system_link,       &amp;
   system_mkfifo, system_remove, system_rename,           &amp;
   system_umask, system_unlink, fileglob,                 &amp;
   system_rmdir, system_chdir, system_mkdir,              &amp;
   system_stat, system_isdir, system_islnk, system_isreg, &amp;
   system_isblk, system_ischr, system_isfifo,             &amp;
   system_realpath,                                       &amp;
   system_access,                                         &amp;
   system_utime,                                          &amp;
   system_issock, system_perm,                            &amp;
   system_memcpy
<br />   !!use M_system, only : system_getc, system_putc
   ! ERROR PROCESSING
   use M_system, only : system_errno, system_perror
   ! INFO
   use M_system, only : system_getegid, system_geteuid, system_getgid, &amp;
   system_gethostname, system_getpid, system_getppid, system_setsid, &amp;
   system_getsid, system_getuid, system_uname
   ! SIGNALS
   use M_system, only : system_kill
   ! RANDOM NUMBERS
   use M_system, only : system_rand, system_srand
   ! PROCESS INFORMATION
   use M_system, only : system_cpu_time
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        <b>M_system</b>(3fm) is a collection of Fortran procedures that call C or a C wrapper using the ISO_C_BINDING interface to access system calls.
        System calls are a special set of functions used by programs to communicate directly with an operating system.

        <p>Generally, system calls are slower than normal function calls because when you make a call control is relinquished to the operating system to
        perform the system call. In addition, depending on the nature of the system call, your program may be blocked by the OS until the system call has
        finished, thus making the execution time of your program even longer.</p>

        <p>One rule-of-thumb that should always be followed when calling a system call -- Always check the return value.</p>
      </blockquote><a name="3"></a>

      <h3><a name="3">ENVIRONMENT ACCESS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_putenv</b>(3f): call <b>putenv</b>(3c)</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_getenv</b>(3f): function call to <b>get_environment_variable</b>(3f)</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_unsetenv</b>(3f): call <b>unsetenv</b>(3c) to remove variable from environment</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>set_environment_variable</b>(3f): set environment variable by calling <b>setenv</b>(3c)</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_initenv</b>(3f): initialize environment table for reading</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_readenv</b>(3f): read next entry from environment table</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_clearenv</b>(3f): emulate <b>clearenv</b>(3c) to clear environment</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">FILE SYSTEM</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_chdir</b>(3f): call <b>chdir</b>(3c) to change current directory of a process</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_getcwd</b>(3f): call <b>getcwd</b>(3c) to get pathname of current working directory</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_stat</b>(3f): determine system information of file by name</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_perm</b>(3f): create string representing file permission and type</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_access</b>(3f): determine filename access or existence</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_isdir</b>(3f): determine if filename is a directory</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_islnk</b>(3f): determine if filename is a link</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_isreg</b>(3f): determine if filename is a regular file</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_isblk</b>(3f): determine if filename is a block device</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_ischr</b>(3f): determine if filename is a character device</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_isfifo</b>(3f): determine if filename is a fifo - named pipe</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_issock</b>(3f): determine if filename is a socket</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_realpath</b>(3f): resolve a pathname</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_chmod</b>(3f): call <b>chmod</b>(3c) to set file permission mode</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_chown</b>(3f): call <b>chown</b>(3c) to set file owner</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_getumask</b>(3f): call <b>umask</b>(3c) to get process permission mask</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_setumask</b>(3f): call <b>umask</b>(3c) to set process permission mask</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_mkdir</b>(3f): call <b>mkdir</b>(3c) to create empty directory</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_mkfifo</b>(3f): call <b>mkfifo</b>(3c) to create a special FIFO file</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_link</b>(3f): call <b>link</b>(3c) to create a filename link</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_rename</b>(3f): call <b>rename</b>(3c) to change filename</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_remove</b>(3f): call <b>remove</b>(3c) to remove file</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_rmdir</b>(3f): call <b>rmdir</b>(3c) to remove empty directory</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_unlink</b>(3f): call <b>unlink</b>(3c) to remove a link to a file</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_utime</b>(3f): call <b>utime</b>(3c) to set file access and modification times</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>fileglob</b>(3f): Returns list of files using a file globbing pattern</td>
          </tr>
        </table>
      </blockquote><a name="5"></a>

      <h3><a name="5">STREAM IO</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_getc</b>(3f): get a character from stdin</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_putc</b>(3f): put a character on stdout</td>
          </tr>
        </table>
      </blockquote><a name="6"></a>

      <h3><a name="6">RANDOM NUMBERS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_srand</b>(3f): call <b>srand</b>(3c)</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_rand</b>(3f): call <b>rand</b>(3c)</td>
          </tr>
        </table>
      </blockquote><a name="7"></a>

      <h3><a name="7">C ERROR INFORMATION</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_errno</b>(3f): return <b>errno</b>(3c)</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_perror</b>(3f): call <b>perror</b>(3c) to display last C error message</td>
          </tr>
        </table>
      </blockquote><a name="8"></a>

      <h3><a name="8">QUERIES</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_geteuid</b>(3f): call <b>geteuid</b>(3c)</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_getuid</b>(3f): call <b>getuid</b>(3c)</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_getegid</b>(3f): call <b>getegid</b>(3c)</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_getgid</b>(3f): call <b>getgid</b>(3c)</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_getpid</b>(3f): call <b>getpid</b>(3c)</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_getppid</b>(3f): call <b>getppid</b>(3c)</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_gethostname</b>(3f): get name of current host</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_uname</b>(3f): call <b>my_uname</b>(3c) which calls <b>uname</b>(3c)</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_getlogin</b>(3f): get login name</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_getpwuid</b>(3f): get login name associated with given UID</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_getgrgid</b>(3f): get group name associated with given GID</td>
          </tr>

          <tr valign="top">
            <td class="c2" width="6%" nowrap="nowrap">o</td>

            <td valign="bottom"><b>system_cpu_time</b>(3f) : get processor time in seconds using <b>times</b>(3c)</td>
          </tr>
        </table>
      </blockquote><a name="9"></a>

      <h3><a name="9">FUTURE DIRECTIONS</a></h3>

      <blockquote>
        A good idea of what system routines are commonly required is to refer to the POSIX binding standards. (Note: IEEE 1003.9-1992 was withdrawn 6
        February 2003.) The IEEE standard covering Fortran 77 POSIX bindings is available online, though currently (unfortunately) only from locations with
        appropriate subscriptions to the IEEE server (e.g., many university networks). For those who do have such access, the link is: POSIX Fortran 77
        Language Interfaces (IEEE Std 1003.9-1992) (pdf)
      </blockquote><a name="10"></a>

      <h3><a name="10">SEE ALSO</a></h3>

      <blockquote>
        Some vendors provide their own way to access POSIX functions and make those available as modules; for instance ...

        <blockquote>
          <table cellpadding="3">
            <!-- tsb: Some vendors provide their own way to access POSIX functions and make
 -->

            <tr valign="top">
              <td width="3%">o</td>

              <td>the IFPORT module of Intel</td>
            </tr>

            <tr valign="top">
              <td width="3%">o</td>

              <td>or the f90_* modules of NAG.</td>
            </tr>

            <tr valign="top">
              <td width="3%">o</td>

              <td>
                There are also other compiler-independent efforts to make the POSIX procedures accessible from Fortran...

                <table width="100%" cellpadding="3">
                  <tr valign="top">
                    <td width="3%">o</td>

                    <td>Posix90 (doc),</td>
                  </tr>

                  <tr valign="top">
                    <td width="3%">o</td>

                    <td>flib.a platform/files and directories,</td>
                  </tr>

                  <tr valign="top">
                    <td width="3%">o</td>

                    <td>fortranposix.</td>
                  </tr>
                </table>
              </td>
            </tr>
          </table>
        </blockquote>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c5"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_access(3f)</b> - [M_system] checks accessibility or existence of a pathname <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="6"></a>

      <h3><a name="6">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
logical function <b>system_access</b>(pathname,amode)
<br />   character(len=*),intent(in) :: pathname
   integer,intent(in)          :: amode
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        <p>The <b>system_access</b>(3f) function checks pathname existence and access permissions. The function checks the pathname for accessibility
        according to the bit pattern contained in amode, using the real user ID in place of the effective user ID and the real group ID in place of the
        effective group ID.</p>

        <p>The value of amode is either the bitwise-inclusive OR of the access permissions to be checked (R_OK, W_OK, X_OK) or the existence test
        (F_OK).</p>
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c6" colspan="2">pathname</td>
          </tr>

          <tr valign="top">
            <td width="6%"></td>

            <td>a character string representing a directory pathname. Trailing spaces are ignored.</td>
          </tr>

          <tr valign="top">
            <td class="c6" width="6%" nowrap="nowrap">amode</td>

            <td valign="bottom">bitwise-inclusive OR of the values R_OK, W_OK, X_OK, or F_OK.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">RETURN VALUE</a></h3>

      <blockquote>
        If not true an error occurred or the requested access is not granted
      </blockquote><a name="5"></a>

      <h3><a name="5">EXAMPLE</a></h3>

      <blockquote>
        check if filename is accessible
        <pre>
       Sample program:
<br />          program demo_system_access
          Use M_system, only : system_access, F_OK, R_OK, W_OK, X_OK
          implicit none
          integer                     :: i
          character(len=80),parameter :: names(*)=[ &amp;
          '/usr/bin/bash   ', &amp;
          '/tmp/NOTTHERE   ', &amp;
          '/usr/local      ', &amp;
          '.               ', &amp;
          'PROBABLY_NOT    ']
          do i=1,size(names)
             write(*,*)' does ',trim(names(i)),' exist?    ', system_access(names(i),F_OK)
             write(*,*)' is ',trim(names(i)),' readable?     ', system_access(names(i),R_OK)
             write(*,*)' is ',trim(names(i)),' writeable?    ', system_access(names(i),W_OK)
             write(*,*)' is ',trim(names(i)),' executable?   ', system_access(names(i),X_OK)
          enddo
          end program demo_system_access
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c9"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_chdir(3f)</b> - [M_system] call <b>chdir</b>(3c) from Fortran to change working directory <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="6"></a>

      <h3><a name="6">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
subroutine <b>system_chdir</b>(<i>path</i>, <i>err</i>)
<br />    character(len=*)               :: path
    integer, optional, intent(out) :: err
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        <p><b>system_chdir</b>(3f) changes the current working directory of the calling process to the directory specified in <i>path</i>. The current
        working directory is the starting point for interpreting relative pathnames (those not starting with '/').</p>
      </blockquote><a name="3"></a>

      <h3><a name="3">RETURN VALUE</a></h3>

      <blockquote>
        <p>On success, zero is returned. On error, <b>-1</b> is returned, and errno is set appropriately.</p>
      </blockquote>

      <blockquote>
        Depending on the file system, other errors can be returned. The more general errors for <b>chdir</b>() are listed below, by their C definitions:

        <p>Errors</p>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c10" width="6%" nowrap="nowrap">EACCES</td>

            <td valign="bottom">Search permission is denied for one of the components of <i>path</i>. (See also <b>path_resolution</b>(7).)</td>
          </tr>

          <tr valign="top">
            <td class="c10" width="6%" nowrap="nowrap">EFAULT</td>

            <td valign="bottom"><i>path</i> points outside your accessible address space.</td>
          </tr>

          <tr valign="top">
            <td class="c10" width="6%" nowrap="nowrap">EIO</td>

            <td valign="bottom">An I/O error occurred.</td>
          </tr>

          <tr valign="top">
            <td class="c10" width="6%" nowrap="nowrap">ELOOP</td>

            <td valign="bottom">Too many symbolic links were encountered in resolving <i>path</i>.</td>
          </tr>

          <tr valign="top">
            <td class="c10" colspan="2">ENAMETOOLONG</td>
          </tr>

          <tr valign="top">
            <td width="6%"></td>

            <td><i>path</i> is too long.</td>
          </tr>

          <tr valign="top">
            <td class="c10" width="6%" nowrap="nowrap">ENOENT</td>

            <td valign="bottom">The file does not exist.</td>
          </tr>

          <tr valign="top">
            <td class="c10" width="6%" nowrap="nowrap">ENOMEM</td>

            <td valign="bottom">Insufficient kernel memory was available.</td>
          </tr>

          <tr valign="top">
            <td class="c10" colspan="2">ENOTDIR</td>
          </tr>

          <tr valign="top">
            <td width="6%"></td>

            <td>A component of <i>path</i> is not a directory.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">SEE ALSO</a></h3>

      <blockquote>
        <p><b>chroot</b>(2), <b>getcwd</b>(3), <b>path_resolution</b>(7)</p>
      </blockquote><a name="5"></a>

      <h3><a name="5">EXAMPLE</a></h3>

      <blockquote>
        Change working directory from Fortran
        <pre>
     program demo_system_chdir
     use M_system, only : system_chdir
     implicit none
     integer :: ierr
<br />     call execute_command_line('pwd')
     call system_chdir('/tmp',ierr)
     call execute_command_line('pwd')
     write(*,*)'*CHDIR TEST* IERR=',ierr
<br />     end program demo_system_chdir
<br />
</pre>
      </blockquote>RESULTS: Sample run output:
      <pre>
     /home/urbanjs/V600
     /tmp
     *CHDIR TEST* IERR=           0
<br />
</pre>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c13"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_chmod(3f)</b> - [M_system] call <b>chmod</b>(3c) to change permission mode of a file relative to directory file descriptor
        <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="7"></a>

      <h3><a name="7">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
function <b>system_chmod</b>(filename,mode) <b>result</b>(<i>ierr</i>)
<br />      character(len=*),intent(in)  :: filename
      integer,value,intent(in)     :: mode
      integer                      :: ierr
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>system_chmod</b>(3f) function shall change UID, _ISGID, S_ISVTX, and the file permission bits of the file named by the pathname pointed to by
        the path argument to the corresponding bits in the mode argument. The application shall ensure that the effective user ID of the process matches the
        owner of the file or the process has appropriate privileges in order to do this.

        <p>S_ISUID, S_ISGID, S_ISVTX, and the file permission bits are described in &lt;sys/stat.h&gt;.</p>

        <p>If the calling process does not have appropriate privileges, and if the group ID of the file does not match the effective group ID or one of the
        supplementary group IDs and if the file is a regular file, bit S_ISGID (set-group-ID on execution) in the file's mode shall be cleared upon
        successful return from <b>chmod</b>().</p>

        <p>Additional implementation-defined restrictions may cause the S_ISUID and S_ISGID bits in mode to be ignored.</p>

        <p>Upon successful completion, <b>system_chmod</b>() marks for update the last file status change timestamp of the file.</p>

        <p>Values for flag are constructed by a bitwise-inclusive OR of flags from the following list, defined in &lt;fcntl.h&gt;:</p>
      </blockquote><a name=""></a>

      <h4><a name="">AT_SYMLINK_NOFOLLOW</a></h4>

      <blockquote>
        If path names a symbolic link, then the mode of the symbolic link is changed.
      </blockquote>

      <p><a name="3"></a></p>

      <h3><a name="3">RETURN VALUE</a></h3>

      <blockquote>
        Upon successful completion, <b>system_chmod</b>(3f) returns 0. Otherwise, it returns <b>-1</b> and sets errno to indicate the error. If <b>-1</b> is
        returned, no change to the file mode occurs.
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLES</a></h3>

      <blockquote>
        Sample program:
        <pre>
   program demo_system_chmod
   use M_system, only : system_chmod
   use M_system, only : system_stat
   use M_system, only : R_GRP,R_OTH,R_USR,RWX_G,RWX_O
   use M_system, only : RWX_U,W_GRP,W_OTH,W_USR,X_GRP,X_OTH,X_USR
   use M_system, only : DEFFILEMODE, ACCESSPERMS
   use,intrinsic     :: iso_fortran_env, only : int64
   implicit none
   integer         :: ierr
   integer         :: status
   integer(kind=int64) :: buffer(13)
      !Setting Read Permissions for User, Group, and Others
      ! The following example sets read permissions for the owner, group, and others.
      open(file='_test1',unit=10)
      write(10,*)'TEST FILE 1'
      close(unit=10)
      ierr=system_chmod('_test1', IANY([R_USR,R_GRP,R_OTH]))
<br />      !Setting Read, Write, and Execute Permissions for the Owner Only
      ! The following example sets read, write, and execute permissions for the owner, and no permissions for group and others.
      open(file='_test2',unit=10)
      write(10,*)'TEST FILE 2'
      close(unit=10)
      ierr=system_chmod('_test2', RWX_U)
<br />      !Setting Different Permissions for Owner, Group, and Other
      ! The following example sets owner permissions for CHANGEFILE to read, write, and execute, group permissions to read and
      ! execute, and other permissions to read.
      open(file='_test3',unit=10)
      write(10,*)'TEST FILE 3'
      close(unit=10)
      ierr=system_chmod('_test3', IANY([RWX_U,R_GRP,X_GRP,R_OTH]));
<br />      !Setting and Checking File Permissions
      ! The following example sets the file permission bits for a file named /home/cnd/mod1, then calls the stat() function to
      ! verify the permissions.
<br />      ierr=system_chmod("home/cnd/mod1", IANY([RWX_U,RWX_G,R_OTH,W_OTH]))
      call system_stat("home/cnd/mod1", buffer,status)
<br />      ! In order to ensure that the S_ISUID and S_ISGID bits are set, an application requiring this should use stat() after a
      ! successful chmod() to verify this.
<br />      !    Any files currently open could possibly become invalid if the mode
      !    of the file is changed to a value which would deny access to
      !    that process.
<br />   end program demo_system_chmod
<br /><br />
</pre>
      </blockquote>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c16"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_chown(3f)</b> - [M_system] change file owner and group <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="6"></a>

      <h3><a name="6">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
logical function <b>system_chown</b>(path,owner,group)
<br />   character(len=*),intent(in) :: path
   integer,intent(in)          :: owner
   integer,intent(in)          :: group
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>chown</b>(3f) function changes owner and group of a file

        <p>The path argument points to a pathname naming a file. The user ID and group ID of the named file shall be set to the numeric values contained in
        owner and group, respectively.</p>

        <p>Only processes with an effective user ID equal to the user ID of the file or with appropriate privileges may change the ownership of a file.</p>
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c17" width="6%" nowrap="nowrap">path</td>

            <td valign="bottom">a character string representing a file pathname. Trailing spaces are ignored.</td>
          </tr>

          <tr valign="top">
            <td class="c17" width="6%" nowrap="nowrap">owner</td>

            <td valign="bottom">UID of owner that ownership is to be changed to</td>
          </tr>

          <tr valign="top">
            <td class="c17" width="6%" nowrap="nowrap">group</td>

            <td valign="bottom">GID of group that ownership is to be changed to</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">RETURN VALUE</a></h3>

      <blockquote>
        The <b>system_chown</b>() function should return zero (0) if successful. Otherwise, these functions shall return 1 and set errno to indicate the
        error. If 1 is returned, no changes are made in the user ID and group ID of the file.
      </blockquote><a name="5"></a>

      <h3><a name="5">EXAMPLE</a></h3>

      <blockquote>
        <p>Sample program:</p>
        <pre>
   program demo_system_chown
   Use M_system, only : system_chown
   Use M_system, only : system_getuid
   Use M_system, only : system_getgid
   use M_system, only : system_perror
   implicit none
   integer                     :: i
   character(len=80),parameter :: names(*)=[character(len=80) :: 'myfile1','/usr/local']
   do i=1,size(names)
      if(.not.  system_chown(&amp;
      &amp; trim(names(i)),  &amp;
      &amp; system_getuid(), &amp;
      &amp; system_getgid()) &amp;
         )then
         call system_perror('*demo_system_chown* '//trim(names(i)))
      endif
   enddo
   end program demo_system_chown
<br />
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c20"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_clearenv(3f)</b> - [M_system:ENVIRONMENT] clear environment by calling <b>clearenv</b>(3c) <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="7"></a>

      <h3><a name="7">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
subroutine <b>system_clearenv</b>(<i>ierr</i>)
<br />    integer,intent(out),optional :: ierr
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>clearenv</b>() procedure clears the environment of all name-value

        <table cellpadding="3">
          <tr valign="top">
            <td class="c21" width="6%" nowrap="nowrap">pairs.</td>

            <td valign="bottom">Typically used in security-conscious applications or ones where configuration control requires ensuring specific variables
            are set.</td>
          </tr>
        </table>
      </blockquote><a name="3"></a>

      <h3><a name="3">RETURN VALUES</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c22" width="6%" nowrap="nowrap">ierr</td>

            <td valign="bottom">returns zero on success, and a nonzero value on failure. Optional. If not present and an error occurs the program
            stops.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLE</a></h3>

      <blockquote>
        <p>Sample program:</p>
        <pre>
     program demo_system_clearenv
     use M_system, only : system_clearenv
     implicit none
     ! environment before clearing
     call execute_command_line('env|wc')
     ! environment after clearing (not necessarily blank!!)
     call system_clearenv()
     call execute_command_line('env')
     end program demo_system_clearenv
<br />
</pre>Typical output:
        <pre>
     89     153    7427
     PWD=/home/urbanjs/V600
     SHLVL=1
<br />
</pre>
      </blockquote>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c28"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_closedir(3f)</b> - [M_system] close a directory stream by calling <b>closedir</b>(3c) <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="8"></a>

      <h3><a name="8">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
subroutine <b>system_closedir</b>(dir,ierr)
<br />        type(c_ptr)         :: dir
        integer,intent(out) :: ierr
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>SYSTEM_CLOSEDIR</b>(3f) function closes the directory stream referred to by the argument DIR. Upon return, the value of DIR may no longer
        point to an accessible object.
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c29" width="6%" nowrap="nowrap">dir</td>

            <td valign="bottom">directory stream pointer opened by <b>SYSTEM_OPENDIR</b>(3f).</td>
          </tr>

          <tr valign="top">
            <td class="c29" width="6%" nowrap="nowrap">ierr</td>

            <td valign="bottom">Upon successful completion, <b>SYSTEM_CLOSEDIR</b>(3f) returns 0; otherwise, an error has occurred.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">ERRORS</a></h3>

      <blockquote>
        <b>system_closedir</b>(3f) may fail if:

        <table cellpadding="3">
          <!-- tsb: <B>system_closedir</B>(3f) may fail if:
 -->

          <tr>
            <td></td>
          </tr>

          <tr>
            <td></td>
          </tr>

          <tr valign="top">
            <td class="c29" width="6%" nowrap="nowrap">EBADF</td>

            <td valign="bottom">The dirp argument does not refer to an open directory stream.</td>
          </tr>

          <tr valign="top">
            <td class="c29" width="6%" nowrap="nowrap">EINTR</td>

            <td valign="bottom">The <b>closedir</b>() function was interrupted by a signal.</td>
          </tr>

          <tr>
            <td></td>
          </tr>
        </table>
      </blockquote><a name="5"></a>

      <h3><a name="5">EXAMPLE</a></h3>

      <blockquote>
        Sample program
        <pre>
   program demo_system_closedir
   use M_system, only : system_opendir,system_readdir
   use M_system, only : system_closedir, system_rewinddir
   use iso_c_binding, only : c_ptr
   implicit none
   type(c_ptr)                  :: dir
   character(len=:),allocatable :: filename
   integer                      :: ierr
   !--- open directory stream to read from
   call system_opendir('.',dir,ierr)
   !--- read directory stream
   do
      call system_readdir(dir,filename,ierr)
      if(filename.eq.' ')exit
      write(*,*)filename
   enddo
   call system_rewinddir(dir)
   !--- close directory stream
   call system_closedir(dir,ierr)
   end program demo_system_closedir
</pre>
      </blockquote>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c32"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_cpu_time(3f)</b> - [M_system] get processor time by calling <b>times</b>(3c) <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="6"></a>

      <h3><a name="6">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
subroutine <b>system_cpu_time</b>(<i>c_user</i>, <i>c_system</i>, <i>c_total</i>)
<br />        real,intent(out) :: c_total
        real,intent(out) :: c_user
        real,intent(out) :: c_system
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3><a name="3"></a>

      <h3><a name="3">OUTPUT</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c33" colspan="2">c_total</td>
          </tr>

          <tr valign="top">
            <td width="6%"></td>

            <td>total processor time ( <i>c_user</i> + <i>c_system</i> )</td>
          </tr>

          <tr valign="top">
            <td class="c33" width="6%" nowrap="nowrap">c_user</td>

            <td valign="bottom">processor user time</td>
          </tr>

          <tr valign="top">
            <td class="c33" colspan="2">c_system</td>
          </tr>

          <tr valign="top">
            <td width="6%"></td>

            <td>processor system time</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">ERRORS</a></h3>

      <blockquote>
        No errors are defined.
      </blockquote><a name="5"></a>

      <h3><a name="5">EXAMPLES</a></h3>

      <blockquote>
        <p>Sample program:</p>
        <pre>
   program demo_system_cpu_time
<br />   use M_system, only : system_cpu_time
   use ISO_C_BINDING, only : c_float
   implicit none
   real    :: user_start, system_start, total_start
   real    :: user_finish, system_finish, total_finish
   integer :: i
   integer :: itimes=1000000
   real    :: value
<br />      call system_cpu_time(total_start,user_start,system_start)
<br />      value=0.0
      do i=1,itimes
         value=sqrt(real(i)+value)
      enddo
      write(10,*)value
      flush(10)
      write(*,*)'average sqrt value=',value/itimes
      call system_cpu_time(total_finish,user_finish,system_finish)
      write(*,*)'USER ......',user_finish-user_start
      write(*,*)'SYSTEM ....',system_finish-system_start
      write(*,*)'TOTAL .....',total_finish-total_start
<br />
</pre>

        <blockquote>
          end program demo_system_cpu_time
        </blockquote>

        <p>Typical Results:</p>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c35"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_errno(3f)</b> - [M_system] C error return value <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="4"></a>

      <h3><a name="4">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
<b>integer</b>(kind=c_int) function <b>system_errno</b>()
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        Many C routines return an error code which can be queried by errno. The <b>M_system</b>(3fm) is primarily composed of Fortran routines that call C
        routines. In the cases where an error code is returned vi <b>system_errno</b>(3f) these routines will indicate it.
      </blockquote><a name="3"></a>

      <h3><a name="3">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
   program demo_system_errno
   use M_system, only : system_errno, system_unlink, system_perror
   implicit none
   integer :: stat
   stat=system_unlink('not there/OR/anywhere')
   if(stat.ne.0)then
           write(*,*)'err=',system_errno()
           call system_perror('*demo_system_errno*')
   endif
   end program demo_system_errno
<br />
</pre>Typical Results:
        <pre>
   err=           2
   *demo_system_errno*: No such file or directory
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c38"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_getcwd(3f)</b> - [M_system] call <b>getcwd</b>(3c) to get the pathname of the current working directory <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="7"></a>

      <h3><a name="7">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
subroutine <b>system_getcwd</b>(output,ierr)
<br />       character(len=:),allocatable,intent(out) :: output
       integer,intent(out)                      :: ierr
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        <b>system_getcwd</b>(3f) calls the C routine <b>getcwd</b>(3c) to obtain the absolute pathname of the current working directory.
      </blockquote><a name="3"></a>

      <h3><a name="3">RETURN VALUE</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c39" width="6%" nowrap="nowrap">OUTPUT</td>

            <td valign="bottom">The absolute pathname of the current working directory The pathname shall contain no components that are dot or dot-dot, or
            are symbolic links.</td>
          </tr>

          <tr valign="top">
            <td class="c39" width="6%" nowrap="nowrap">IERR</td>

            <td valign="bottom">is not zero if an error occurs.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
     program demo_system_getcwd
     use M_system, only : system_getcwd
     implicit none
     character(len=:),allocatable :: dirname
     integer                      :: ierr
     call system_getcwd(dirname,ierr)
     if(ierr.eq.0)then
        write(*,*)'CURRENT DIRECTORY ',trim(dirname)
     else
        write(*,*)'ERROR OBTAINING CURRENT DIRECTORY NAME'
     endif
     end program demo_system_getcwd
<br />
</pre>
      </blockquote>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c42"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_getegid(3f)</b> - [M_system:QUERY] get the effective group ID (GID) of current process from Fortran by calling <b>getegid</b>(3c)
        <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="7"></a>

      <h3><a name="7">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
<b>integer</b>(kind=c_int) function <b>system_getegid</b>()
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>getegid</b>() function returns the effective group ID of the calling process.
      </blockquote><a name="3"></a>

      <h3><a name="3">RETURN VALUE</a></h3>

      <blockquote>
        The <b>getegid</b>() should always be successful and no return value is reserved to indicate an error.
      </blockquote><a name="4"></a>

      <h3><a name="4">ERRORS</a></h3>

      <blockquote>
        No errors are defined.
      </blockquote><a name="5"></a>

      <h3><a name="5">SEE ALSO</a></h3>

      <blockquote>
        <b>getegid</b>(), <b>system_geteuid</b>(), <b>getuid</b>(), <b>setegid</b>(), <b>seteuid</b>(), <b>setgid</b>(), <b>setregid</b>(),
        <b>setreuid</b>(), <b>setuid</b>()
      </blockquote><a name="6"></a>

      <h3><a name="6">EXAMPLE</a></h3>

      <blockquote>
        Get group ID from Fortran
        <pre>
   program demo_system_getegid
   use M_system, only : system_getegid
   implicit none
      write(*,*)'GID=',system_getegid()
   end program demo_system_getegid
<br />
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c45"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_getenv(3f)</b> - [M_system:ENVIRONMENT] get environment variable from Fortran by calling <b>get_environment_variable</b>(3f)
        <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="7"></a>

      <h3><a name="7">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
function <b>system_getenv</b>(<i>name</i>)
<br />    character(len=:),allocatable   :: system_getenv
    character(len=*),intent(in)    :: name
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>system_getenv</b>() function gets the value of an environment variable.
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c46" width="6%" nowrap="nowrap">name</td>

            <td valign="bottom">Return the value of the specified environment variable or blank if the variable is not defined.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLE</a></h3>

      <blockquote>
        Sample setting an environment variable from Fortran:
        <pre>
   program demo_system_getenv
   use M_system, only : system_getenv
   implicit none
   integer :: ierr
<br />      write(*,'("USER     : ",a)')system_getenv('USER')
      write(*,'("LOGNAME  : ",a)')system_getenv('LOGNAME')
      write(*,'("USERNAME : ",a)')system_getenv('USERNAME')
<br />
</pre>

        <blockquote>
          end program demo_system_getenv
        </blockquote>
      </blockquote><a name="5"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c48"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_geteuid(3f)</b> - [M_system:QUERY] get effective UID of current process from Fortran by calling <b>geteuid</b>(3c) <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="4"></a>

      <h3><a name="4">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
<b>integer</b>(kind=c_int) function <b>system_geteuid</b>()
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>system_geteuid</b>(3f) function shall return the effective user ID of the calling process. The <b>geteuid</b>() function shall always be
        successful and no return value is reserved to indicate the error.
      </blockquote><a name="3"></a>

      <h3><a name="3">EXAMPLE</a></h3>

      <blockquote>
        Get group ID from Fortran:
        <pre>
   program demo_system_geteuid
   use M_system, only : system_geteuid
   implicit none
      write(*,*)'EFFECTIVE UID=',system_geteuid()
   end program demo_system_geteuid
<br />
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c51"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_getgid(3f)</b> - [M_system:QUERY] get the real group ID (GID) of current process from Fortran by calling <b>getgid</b>(3c)
        <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="7"></a>

      <h3><a name="7">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
<b>integer</b>(kind=c_int) function <b>system_getgid</b>()
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>getgid</b>() function returns the real group ID of the calling process.
      </blockquote><a name="3"></a>

      <h3><a name="3">RETURN VALUE</a></h3>

      <blockquote>
        The <b>getgid</b>() should always be successful and no return value is reserved to indicate an error.
      </blockquote><a name="4"></a>

      <h3><a name="4">ERRORS</a></h3>

      <blockquote>
        No errors are defined.
      </blockquote><a name="5"></a>

      <h3><a name="5">SEE ALSO</a></h3>

      <blockquote>
        <b>getegid</b>(), <b>system_geteuid</b>(), <b>getuid</b>(), <b>setegid</b>(), <b>seteuid</b>(), <b>setgid</b>(), <b>setregid</b>(),
        <b>setreuid</b>(), <b>setuid</b>()
      </blockquote><a name="6"></a>

      <h3><a name="6">EXAMPLE</a></h3>

      <blockquote>
        Get group ID from Fortran
        <pre>
   program demo_system_getgid
   use M_system, only : system_getgid
   implicit none
      write(*,*)'GID=',system_getgid()
   end program demo_system_getgid
<br />
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c54"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_getgrgid(3f)</b> - [M_system:QUERY] get groupd name associated with a GID <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="8"></a>

      <h3><a name="8">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
function <b>system_getgrgid</b>(<i>gid</i>) result (<i>gname</i>)
<br />   class(*),intent(in)          :: gid   ! any INTEGER type
   character(len=:),allocatable :: gname
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        <p>The <b>system_getlogin</b>() function returns a string containing the group name associated with the given GID. If no match is found it returns a
        null string and sets errno to indicate the error.</p>
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTION</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c55" width="6%" nowrap="nowrap">gid</td>

            <td valign="bottom">GID to try to look up associated group for. Can be of any INTEGER type.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">RETURN VALUE</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c55" width="6%" nowrap="nowrap">gname</td>

            <td valign="bottom">returns the group name. Blank if an error occurs</td>
          </tr>
        </table>
      </blockquote><a name="5"></a>

      <h3><a name="5">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
   program demo_system_getgrgid
   use M_system, only : system_getgrgid
   use M_system, only : system_getgid
   implicit none
   character(len=:),allocatable :: name
   name=system_getgrgid( system_getgid() )
   write(*,'("group[",a,"] for ",i0)')name,system_getgid()
   end program demo_system_getgrgid
<br />
</pre>Results:
        <pre>
   group[default] for 197121
<br />
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c57"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_gethostname(3f)</b> - [M_system:QUERY] get name of current host <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="7"></a>

      <h3><a name="7">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
subroutine <b>system_gethostname</b>(string,ierr)
<br />       character(len=:),allocatable,intent(out) :: NAME
       integer,intent(out)                      :: IERR
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>system_gethostname</b>(3f) procedure returns the standard host name for the current machine.
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c58" width="6%" nowrap="nowrap">string</td>

            <td valign="bottom">returns the hostname. Must be an allocatable CHARACTER variable.</td>
          </tr>

          <tr valign="top">
            <td class="c58" width="6%" nowrap="nowrap">ierr</td>

            <td valign="bottom">Upon successful completion, 0 shall be returned; otherwise, <b>-1</b> shall be returned.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
   program demo_system_gethostname
<br />   use M_system, only : system_gethostname
   implicit none
   character(len=:),allocatable :: name
   integer                      :: ierr
<br />      call system_gethostname(name,ierr)
      if(ierr.eq.0)then
         write(*,'("hostname[",a,"]")')name
      else
         write(*,'(a)')'ERROR: could not get hostname'
      endif
<br />
</pre>

        <blockquote>
          end program demo_system_gethostname
        </blockquote>
      </blockquote><a name="5"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c61"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_getlogin(3f)</b> - [M_system:QUERY] get login name <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="7"></a>

      <h3><a name="7">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
function <b>system_getlogin</b>() result (<i>fname</i>)
<br />   character(len=:),allocatable :: FNAME
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        <p>The <b>system_getlogin</b>() function returns a string containing the user name associated by the login activity with the controlling terminal of
        the current process. Otherwise, it returns a null string and sets errno to indicate the error.</p>

        <p>Three names associated with the current process can be determined:</p>

        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td width="3%">o</td>

              <td><b>system_getpwuid</b>(system_getuid()) returns the name associated with the real user ID of the process.</td>
            </tr>

            <tr valign="top">
              <td width="3%">o</td>

              <td><b>system_getpwuid</b>(system_geteuid()) returns the name associated with the effective user ID of the process</td>
            </tr>

            <tr valign="top">
              <td width="3%">o</td>

              <td><b>system_getlogin</b>() returns the name associated with the current login activity</td>
            </tr>
          </table>
        </blockquote>
      </blockquote><a name="3"></a>

      <h3><a name="3">RETURN VALUE</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c62" colspan="2">fname</td>
          </tr>

          <tr valign="top">
            <td width="3%"></td>

            <td>returns the login name.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
   program demo_system_getlogin
   use M_system, only : system_getlogin
   implicit none
   character(len=:),allocatable :: name
   name=system_getlogin()
   write(*,'("login[",a,"]")')name
   end program demo_system_getlogin
<br />
</pre>Results:
        <pre>
   login[JSU]
<br />
</pre>
      </blockquote><a name="5"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c64"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_getpid(3f)</b> - [M_system:QUERY] get PID (process ID) of current process from Fortran by calling <b>getpid</b>(3c) <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="5"></a>

      <h3><a name="5">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
integer function <b>system_getpid</b>()
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>system_getpid</b>() function returns the process ID of the calling process.
      </blockquote><a name="3"></a>

      <h3><a name="3">RETURN VALUE</a></h3>

      <blockquote>
        The value returned is the integer process ID. The <b>system_getpid</b>() function shall always be successful and no return value is reserved to
        indicate an error.
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLE</a></h3>

      <blockquote>
        Get process PID from Fortran
        <pre>
   program demo_system_getpid
   use M_system, only : system_getpid
   implicit none
      write(*,*)'PID=',system_getpid()
   end program demo_system_getpid
<br />
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c67"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_getppid(3f)</b> - [M_system:QUERY] get parent process ID (PPID) of current process from Fortran by calling <b>getppid</b>(3c)
        <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="7"></a>

      <h3><a name="7">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
<b>integer</b>(kind=c_int) function <b>system_getppid</b>()
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>system_getppid</b>() function returns the parent process ID of the calling process.
      </blockquote><a name="3"></a>

      <h3><a name="3">RETURN VALUE</a></h3>

      <blockquote>
        The <b>system_getppid</b>() function should always be successful and no return value is reserved to indicate an error.
      </blockquote><a name="4"></a>

      <h3><a name="4">ERRORS</a></h3>

      <blockquote>
        No errors are defined.
      </blockquote><a name="5"></a>

      <h3><a name="5">SEE ALSO</a></h3>

      <blockquote>
        exec, <b>fork</b>(), <b>getpgid</b>(), <b>getpgrp</b>(), <b>getpid</b>(), <b>kill</b>(), <b>setpgid</b>(), <b>setsid</b>()
      </blockquote><a name="6"></a>

      <h3><a name="6">EXAMPLE</a></h3>

      <blockquote>
        Get parent process PID (PPID) from Fortran
        <pre>
   program demo_system_getppid
   use M_system, only : system_getppid
   implicit none
<br />   write(*,*)'PPID=',system_getppid()
<br />   end program demo_system_getppid
<br />
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c70"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_getpwuid(3f)</b> - [M_system:QUERY] get login name associated with a UID <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="8"></a>

      <h3><a name="8">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
function <b>system_getpwuid</b>(<i>uid</i>) result (<i>uname</i>)
<br />   class(*),intent(in)          :: uid    ! any INTEGER type
   character(len=:),allocatable :: uname
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        <p>The <b>system_getpwuid</b>() function returns a string containing the user name associated with the given UID. If no match is found it returns a
        null string and sets errno to indicate the error.</p>
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTION</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c71" width="6%" nowrap="nowrap">uid</td>

            <td valign="bottom">UID to try to look up associated username for. Can be of any INTEGER type.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">RETURN VALUE</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c71" width="6%" nowrap="nowrap">uname</td>

            <td valign="bottom">returns the login name.</td>
          </tr>
        </table>
      </blockquote><a name="5"></a>

      <h3><a name="5">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
   program demo_system_getpwuid
   use M_system, only : system_getpwuid
   use M_system, only : system_getuid
   use,intrinsic     :: iso_fortran_env, only : int64
   implicit none
   character(len=:),allocatable :: name
   integer(kind=int64)              :: uid
      uid=system_getuid()
      name=system_getpwuid(uid)
      write(*,'("login[",a,"] has UID ",i0)')name,uid
   end program demo_system_getpwuid
<br />
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c73"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_getsid(3f)</b> - [M_system:QUERY] get the process group ID of a session leader <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="5"></a>

      <h3><a name="5">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
<b>integer</b>(kind=c_int) function <b>system_getsid</b>(<i>pid</i>)
<b>integer</b>(kind=c_int) :: <i>pid</i>
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>system_getsid</b>() function obtains the process group ID of the process that is the session leader of the process specified by <i>pid</i>.
        If <i>pid</i> is 0, it specifies the calling process.
      </blockquote><a name="3"></a>

      <h3><a name="3">RETURN VALUE</a></h3>

      <blockquote>
        Upon successful completion, <b>system_getsid</b>() shall return the process group ID of the session leader of the specified process. Otherwise, it
        shall return <b>-1</b> and set errno to indicate the error.
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLE</a></h3>

      <blockquote>
        Get SID from Fortran
        <pre>
   program demo_system_getsid
   use M_system,      only : system_getsid
   use ISO_C_BINDING, only : c_int
   implicit none
      write(*,*)'SID=',system_getsid(0_c_int)
   end program demo_system_getsid
<br />
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c76"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_getuid(3f)</b> - [M_system:QUERY] get real UID of current process from Fortran by calling <b>getuid</b>(3c) <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="4"></a>

      <h3><a name="4">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
<b>integer</b>(kind=c_int) function <b>system_getuid</b>()
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>system_getuid</b>(3f) function shall return the real user ID of the calling process. The <b>getuid</b>() function shall always be successful
        and no return value is reserved to indicate the error.
      </blockquote><a name="3"></a>

      <h3><a name="3">EXAMPLE</a></h3>

      <blockquote>
        Get group ID from Fortran:
        <pre>
   program demo_system_getuid
   use M_system, only : system_getuid
   implicit none
      write(*,*)'UID=',system_getuid()
   end program demo_system_getuid
<br />
</pre>Results:
        <pre>
   UID=      197609
<br />
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c79"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_getumask(3f)</b> - [M_system] get current umask <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="4"></a>

      <h3><a name="4">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
integer function <b>system_getumask</b>() result (<i>umask_value</i>)
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The return value from <b>getumask</b>(3f) is the value of the file creation mask, obtained by using <b>umask</b>(3c).
      </blockquote><a name="3"></a>

      <h3><a name="3">EXAMPLE</a></h3>

      <blockquote>
        Sample program
        <pre>
   program demo_getumask
   use M_system, only : system_getumask, system_setumask
   integer :: i
   write(*,101)(system_getumask(),i=1,4)
   101 format(1x,i0,1x,"O'",o4.4,"'",1x,'Z"',z0,"'",1x,"B'",b12.12,"'")
   end program demo_getumask
<br />
</pre>Expected output
        <pre>
    18 O'022' Z"12' B'000010010"
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c82"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_initenv(3f)</b> - [M_system:ENVIRONMENT] initialize environment table pointer and size so table can be read by <b>readenv</b>(3f)
        <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a> <a name="4"></a>

      <h3><a name="4">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
subroutine <b>system_initenv</b>()
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        A simple interface allows reading the environment variable table of the process. Call <b>system_initenv</b>(3f) to initialize reading the
        environment table, then call <b>system_readenv</b>(3f) until a blank line is returned. If more than one thread reads the environment or the
        environment is changed while being read the results are undefined.
      </blockquote><a name="3"></a>

      <h3><a name="3">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
   program demo_system_initenv
   use M_system, only : system_initenv, system_readenv
   character(len=:),allocatable :: string
      call system_initenv()
      do
         string=system_readenv()
         if(string.eq.'')then
            exit
         else
            write(*,'(a)')string
         endif
      enddo
   end program demo_system_initenv
<br />
</pre>Sample results:
        <pre>
   USERDOMAIN_ROAMINGPROFILE=buzz
   HOMEPATH=\Users\JSU
   APPDATA=C:\Users\JSU\AppData\Roaming
   MANPATH=/home/urbanjs/V600/LIBRARY/libGPF/download/tmp/man:/home/urbanjs/V600/doc/man:::
   DISPLAYNUM=0
   ProgramW6432=C:\Program Files
   HOSTNAME=buzz
   XKEYSYMDB=/usr/share/X11/XKeysymDB
   PUBLISH_CMD=
   OnlineServices=Online Services
        :
        :
        :
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c85"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_isblk(3f)</b> - [M_system] checks if argument is a block device <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="8">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
logical function <b>system_isblk</b>(<i>pathname</i>)
<br />   character(len=*),intent(in) :: pathname
   logical                     :: system_isblk
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>isblk</b>(3f) function checks if path is a path to a block device.
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c86" width="6%" nowrap="nowrap">path</td>

            <td valign="bottom">a character string representing a block device <i>pathname</i>. Trailing spaces are ignored.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">RETURN VALUE</a></h3>

      <blockquote>
        The <b>system_isblk</b>() function should always be successful and no return value is reserved to indicate an error.
      </blockquote><a name="5"></a>

      <h3><a name="5">ERRORS</a></h3>

      <blockquote>
        No errors are defined.
      </blockquote><a name="6"></a>

      <h3><a name="6">SEE ALSO</a></h3>

      <blockquote>
        <b>system_isreg</b>(3f), <b>system_stat</b>(3f), <b>system_isdir</b>(3f), <b>system_perm</b>(3f)
      </blockquote><a name="7"></a>

      <h3><a name="7">EXAMPLE</a></h3>

      <blockquote>
        check if filename is a block device
        <pre>
   program demo_system_isblk
   Use M_system, only : system_isblk
   implicit none
   integer                     :: i
   character(len=80),parameter :: names(*)=[ &amp;
   '/tmp            ', &amp;
   '/tmp/NOTTHERE   ', &amp;
   '/usr/local      ', &amp;
   '.               ', &amp;
   'block_device.tst', &amp;
   'PROBABLY_NOT    ']
   do i=1,size(names)
       write(*,*)' is ',trim(names(i)),' a block device? ', system_isblk(names(i))
   enddo
   end program demo_system_isblk
<br />
</pre>Results:
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c89"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_ischr(3f)</b> - [M_system] checks if argument is a character device <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="8">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
logical function <b>system_ischr</b>(<i>pathname</i>)
<br />   character(len=*),intent(in) :: pathname
   logical                     :: system_ischr
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>ischr</b>(3f) function checks if path is a path to a character device.
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c90" width="6%" nowrap="nowrap">path</td>

            <td valign="bottom">a character string representing a character device <i>pathname</i>. Trailing spaces are ignored.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">RETURN VALUE</a></h3>

      <blockquote>
        The <b>system_ischr</b>() function should always be successful and no return value is reserved to indicate an error.
      </blockquote><a name="5"></a>

      <h3><a name="5">ERRORS</a></h3>

      <blockquote>
        No errors are defined.
      </blockquote><a name="6"></a>

      <h3><a name="6">SEE ALSO</a></h3>

      <blockquote>
        <b>system_isreg</b>(3f), <b>system_stat</b>(3f), <b>system_isdir</b>(3f), <b>system_perm</b>(3f)
      </blockquote><a name="7"></a>

      <h3><a name="7">EXAMPLE</a></h3>

      <blockquote>
        check if filename is a character file
        <pre>
   program demo_system_ischr
   Use M_system, only : system_ischr
   implicit none
   integer                     :: i
   character(len=80),parameter :: names(*)=[ &amp;
   '/tmp            ', &amp;
   '/tmp/NOTTHERE   ', &amp;
   '/usr/local      ', &amp;
   '.               ', &amp;
   'char_dev.test   ', &amp;
   'PROBABLY_NOT    ']
   do i=1,size(names)
      write(*,*)' is ',trim(names(i)),' a character device? ', system_ischr(names(i))
   enddo
   end program demo_system_ischr
<br />
</pre>Results:
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c93"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_isdir(3f)</b> - [M_system] checks if argument is a directory path <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="8">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
logical function <b>system_isdir</b>(<i>pathname</i>)
<br />   character(len=*),intent(in) :: pathname
   logical                     :: system_isdir
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>system_isdir</b>(3f) function checks if path is a directory.
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c94" width="6%" nowrap="nowrap">path</td>

            <td valign="bottom">a character string representing a directory <i>pathname</i>. Trailing spaces are ignored.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">RETURN VALUE</a></h3>

      <blockquote>
        The <b>system_isdir</b>() function should always be successful and no return value is reserved to indicate an error.
      </blockquote><a name="5"></a>

      <h3><a name="5">ERRORS</a></h3>

      <blockquote>
        No errors are defined.
      </blockquote><a name="6"></a>

      <h3><a name="6">SEE ALSO</a></h3>

      <blockquote>
        <b>system_islnk</b>(3f), <b>system_stat</b>(3f), <b>isreg</b>(3f), <b>system_perm</b>(3f)
      </blockquote><a name="7"></a>

      <h3><a name="7">EXAMPLE</a></h3>

      <blockquote>
        check if filename is a directory
        <pre>
     program demo_system_isdir
     Use M_system, only : system_isdir
     implicit none
     integer                     :: i
     character(len=80),parameter :: names(*)=[ &amp;
     '/tmp            ', &amp;
     '/tmp/NOTTHERE   ', &amp;
     '/usr/local      ', &amp;
     '.               ', &amp;
     'PROBABLY_NOT    ']
     do i=1,size(names)
        write(*,*)' is ',trim(names(i)),' a directory? ', system_isdir(names(i))
     enddo
     end program demo_system_isdir
<br />
</pre>Results:
        <pre>
     is /tmp a directory?  T
     is /tmp/NOTTHERE a directory?  F
     is /usr/local a directory?  T
     is . a directory?  T
     is PROBABLY_NOT a directory?  F
<br />
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c97"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_isfifo(3f)</b> - [M_system] checks if argument is a fifo - named pipe <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="8">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
logical function <b>system_isfifo</b>(<i>pathname</i>)
<br />   character(len=*),intent(in) :: pathname
   logical                     :: system_isfifo
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>isfifo</b>(3f) function checks if path is a path to a fifo - named pipe.
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c98" width="6%" nowrap="nowrap">path</td>

            <td valign="bottom">a character string representing a fifo - named pipe <i>pathname</i>. Trailing spaces are ignored.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">RETURN VALUE</a></h3>

      <blockquote>
        The <b>system_isfifo</b>() function should always be successful and no return value is reserved to indicate an error.
      </blockquote><a name="5"></a>

      <h3><a name="5">ERRORS</a></h3>

      <blockquote>
        No errors are defined.
      </blockquote><a name="6"></a>

      <h3><a name="6">SEE ALSO</a></h3>

      <blockquote>
        <b>system_isreg</b>(3f), <b>system_stat</b>(3f), <b>system_isdir</b>(3f), <b>system_perm</b>(3f)
      </blockquote><a name="7"></a>

      <h3><a name="7">EXAMPLE</a></h3>

      <blockquote>
        check if filename is a FIFO file
        <pre>
   program demo_system_isfifo
   Use M_system, only : system_isfifo
   implicit none
   integer                     :: i
   character(len=80),parameter :: names(*)=[ &amp;
   '/tmp            ', &amp;
   '/tmp/NOTTHERE   ', &amp;
   '/usr/local      ', &amp;
   '.               ', &amp;
   'fifo.test       ', &amp;
   'PROBABLY_NOT    ']
   do i=1,size(names)
      write(*,*)' is ',trim(names(i)),' a fifo(named pipe)? ', system_isfifo(names(i))
   enddo
   end program demo_system_isfifo
<br />
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c101"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_islnk(3f)</b> - [M_system] checks if argument is a link <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="8">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
logical function <b>system_islnk</b>(<i>pathname</i>)
<br /><b>character</b>(len=*),intent(<i>in</i>) :: <i>pathname</i>
</pre>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c102" colspan="2">logical</td>
          </tr>

          <tr valign="top">
            <td width="6%"></td>

            <td>:: system_islnk</td>
          </tr>
        </table>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>islnk</b>(3f) function checks if path is a path to a link.
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c102" width="6%" nowrap="nowrap">path</td>

            <td valign="bottom">a character string representing a link <i>pathname</i>. Trailing spaces are ignored.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">RETURN VALUE</a></h3>

      <blockquote>
        The <b>system_islnk</b>() function should always be successful and no return value is reserved to indicate an error.
      </blockquote><a name="5"></a>

      <h3><a name="5">ERRORS</a></h3>

      <blockquote>
        No errors are defined.
      </blockquote><a name="6"></a>

      <h3><a name="6">SEE ALSO</a></h3>

      <blockquote>
        <b>system_isreg</b>(3f), <b>system_stat</b>(3f), <b>system_isdir</b>(3f), <b>system_perm</b>(3f)
      </blockquote><a name="7"></a>

      <h3><a name="7">EXAMPLE</a></h3>

      <blockquote>
        <p>Sample program:</p>
        <pre>
   program demo_system_islnk
   Use M_system, only : system_islnk
   implicit none
   integer                     :: i
   character(len=80),parameter :: names(*)=[ &amp;
   '/tmp            ', &amp;
   '/tmp/NOTTHERE   ', &amp;
   '/usr/local      ', &amp;
   '.               ', &amp;
   'link.test       ', &amp;
   'PROBABLY_NOT    ']
   do i=1,size(names)
      write(*,*)' is ',trim(names(i)),' a link? ', system_islnk(names(i))
   enddo
   end program demo_system_islnk
<br />
</pre>Results:
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c105"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_isreg(3f)</b> - [M_system] checks if argument is a regular file <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="8">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
logical function <b>system_isreg</b>(<i>pathname</i>)
<br />   character(len=*),intent(in) :: pathname
   logical                     :: system_isreg
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>isreg</b>(3f) function checks if path is a regular file
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c106" width="6%" nowrap="nowrap">path</td>

            <td valign="bottom">a character string representing a <i>pathname</i>. Trailing spaces are ignored.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">RETURN VALUE</a></h3>

      <blockquote>
        The <b>system_isreg</b>() function should always be successful and no return value is reserved to indicate an error.
      </blockquote><a name="5"></a>

      <h3><a name="5">ERRORS</a></h3>

      <blockquote>
        No errors are defined.
      </blockquote><a name="6"></a>

      <h3><a name="6">SEE ALSO</a></h3>

      <blockquote>
        <b>system_islnk</b>(3f), <b>system_stat</b>(3f), <b>system_isdir</b>(3f), <b>system_perm</b>(3f)
      </blockquote><a name="7"></a>

      <h3><a name="7">EXAMPLE</a></h3>

      <blockquote>
        check if filename is a regular file
        <pre>
   program demo_system_isreg
   Use M_system, only : system_isreg
   implicit none
   integer                     :: i
   character(len=80),parameter :: names(*)=[ &amp;
   '/tmp            ', &amp;
   'test.txt        ', &amp;
   '.               ']
   do i=1,size(names)
      write(*,*)' is ',trim(names(i)),' a regular file? ', system_isreg(names(i))
   enddo
   end program demo_system_isreg
<br />
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c109"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_issock(3f)</b> - [M_system] checks if argument is a socket <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="8">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
logical function <b>system_issock</b>(<i>pathname</i>)
<br />   character(len=*),intent(in) :: pathname
   logical                     :: system_issock
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>issock</b>(3f) function checks if path is a path to a socket
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c110" width="6%" nowrap="nowrap">path</td>

            <td valign="bottom">a character string representing a socket <i>pathname</i>. Trailing spaces are ignored.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">RETURN VALUE</a></h3>

      <blockquote>
        The <b>system_issock</b>() function should always be successful and no return value is reserved to indicate an error.
      </blockquote><a name="5"></a>

      <h3><a name="5">ERRORS</a></h3>

      <blockquote>
        No errors are defined.
      </blockquote><a name="6"></a>

      <h3><a name="6">SEE ALSO</a></h3>

      <blockquote>
        <b>system_isreg</b>(3f), <b>system_stat</b>(3f), <b>system_isdir</b>(3f), <b>system_perm</b>(3f)
      </blockquote><a name="7"></a>

      <h3><a name="7">EXAMPLE</a></h3>

      <blockquote>
        check if filename is a socket
        <pre>
   program demo_system_issock
   Use M_system, only : system_issock
   implicit none
   integer                     :: i
   character(len=80),parameter :: names(*)=[ &amp;
   '/tmp            ', &amp;
   '/tmp/NOTTHERE   ', &amp;
   '/usr/local      ', &amp;
   '.               ', &amp;
   'sock.test       ', &amp;
   'PROBABLY_NOT    ']
   do i=1,size(names)
      write(*,*)' is ',trim(names(i)),' a socket? ', system_issock(names(i))
   enddo
   end program demo_system_issock
<br />
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c113"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_kill(3f)</b> - [M_system] send a signal to a process or a group of processes <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="7">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
<b>integer</b>(kind=c_int) function <b>system_kill</b>(pid,sig)
<br />      integer,intent(in) :: pid
      integer,intent(in) :: sig
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        <p>The <b>kill</b>() function shall send a signal to a process or a group of processes specified by pid. The signal to be sent is specified by sig
        and is either one from the list given in &lt;signal.h&gt; or 0. If sig is 0 (the null signal), error checking is performed but no signal is actually
        sent. The null signal can be used to check the validity of pid.</p>

        <p>For a process to have permission to send a signal to a process designated by pid, unless the sending process has appropriate privileges, the real
        or effective user ID of the sending process shall match the real or saved set-user-ID of the receiving process.</p>

        <p>If pid is greater than 0, sig shall be sent to the process whose process ID is equal to pid.</p>

        <p>If pid is 0, sig shall be sent to all processes (excluding an unspecified set of system processes) whose process group ID is equal to the process
        group ID of the sender, and for which the process has permission to send a signal.</p>

        <p>If pid is <b>-1</b>, sig shall be sent to all processes (excluding an unspecified set of system processes) for which the process has permission
        to send that signal.</p>

        <p>If pid is negative, but not <b>-1</b>, sig shall be sent to all processes (excluding an unspecified set of system processes) whose process group
        ID is equal to the absolute value of pid, and for which the process has permission to send a signal.</p>

        <p>If the value of pid causes sig to be generated for the sending process, and if sig is not blocked for the calling thread and if no other thread
        has sig unblocked or is waiting in a <b>sigwait</b>() function for sig, either sig or at least one pending unblocked signal shall be delivered to
        the sending thread before <b>kill</b>() returns.</p>

        <p>The user ID tests described above shall not be applied when sending SIGCONT to a process that is a member of the same session as the sending
        process.</p>

        <p>An implementation that provides extended security controls may impose further implementation-defined restrictions on the sending of signals,
        including the null signal. In particular, the system may deny the existence of some or all of the processes specified by pid.</p>

        <p>The <b>kill</b>() function is successful if the process has permission to send sig to any of the processes specified by pid. If <b>kill</b>()
        fails, no signal shall be sent.</p>
      </blockquote>

      <p><a name="3"></a></p>

      <h3><a name="3">RETURN VALUE</a></h3>

      <blockquote>
        <p>Upon successful completion, 0 shall be returned. Otherwise, <b>-1</b> shall be returned and errno set to indicate the error.</p>
      </blockquote><a name="4"></a>

      <h3><a name="4">ERRORS</a></h3>

      <blockquote>
        The <b>kill</b>() function shall fail if:

        <table cellpadding="3">
          <tr valign="top">
            <td class="c114" width="6%" nowrap="nowrap">EINVAL</td>

            <td valign="bottom">The value of the sig argument is an invalid or unsupported signal number.</td>
          </tr>

          <tr valign="top">
            <td class="c114" width="6%" nowrap="nowrap">EPERM</td>

            <td valign="bottom">The process does not have permission to send the signal to any receiving process.</td>
          </tr>

          <tr valign="top">
            <td class="c114" width="6%" nowrap="nowrap">ESRCH</td>

            <td valign="bottom">No process or process group can be found corresponding to that specified by pid. The following sections are
            informative.</td>
          </tr>

          <tr>
            <td></td>
          </tr>
        </table>
      </blockquote><a name="5"></a>

      <h3><a name="5">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
   program demo_system_kill
   use M_system, only : system_kill
   use M_system, only : system_perror
   implicit none
   integer           :: i,pid,ios,ierr,signal=9
   character(len=80) :: argument
<br />      do i=1,command_argument_count()
         ! get arguments from command line
         call get_command_argument(i, argument)
         ! convert arguments to integers assuming they are PID numbers
         read(argument,'(i80)',iostat=ios) pid
         if(ios.ne.0)then
            write(*,*)'bad PID=',trim(argument)
         else
            write(*,*)'kill SIGNAL=',signal,' PID=',pid
         ! send signal SIGNAL to pid PID
            ierr=system_kill(pid,signal)
         ! write message if an error was detected
            if(ierr.ne.0)then
               call system_perror('*demo_system_kill*')
            endif
         endif
      enddo
</pre>end program demo_system_kill
      </blockquote><a name="6"></a>

      <h3><a name="6">SEE ALSO</a></h3>

      <blockquote>
        <b>getpid</b>(), <b>raise</b>(), <b>setsid</b>(), <b>sigaction</b>(), <b>sigqueue</b>(),
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c117"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_link(3f)</b> - [M_system] link one file to another file relative to two directory file descriptors <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="5">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
integer function <b>link</b>(oldpath,newpath);
<br />    character(len=*),intent(in) :: oldpath
    character(len=*),intent(in) :: newpath
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>link</b>() function shall create a new link (directory entry) for the existing file, path1.

        <p>The path1 argument points to a pathname naming an existing file. The path2 argument points to a pathname naming the new directory entry to be
        created. The <b>link</b>() function shall atomically create a new link for the existing file and the link count of the file shall be incremented by
        one.</p>

        <p>If path1 names a directory, <b>link</b>() shall fail unless the process has appropriate privileges and the implementation supports using
        <b>link</b>() on directories.</p>

        <p>If path1 names a symbolic link, it is implementation-defined whether <b>link</b>() follows the symbolic link, or creates a new link to the
        symbolic link itself.</p>

        <p>Upon successful completion, <b>link</b>() shall mark for update the last file status change timestamp of the file. Also, the last data
        modification and last file status change timestamps of the directory that contains the new entry shall be marked for update.</p>

        <p>If <b>link</b>() fails, no link shall be created and the link count of the file shall remain unchanged.</p>

        <p>The implementation may require that the calling process has permission to access the existing file.</p>

        <p>The <b>linkat</b>() function shall be equivalent to the <b>link</b>() function except that symbolic links shall be handled as specified by the
        value of flag (see below) and except in the case where either path1 or path2 or both are relative paths. In this case a relative path path1 is
        interpreted relative to the directory associated with the file descriptor fd1 instead of the current working directory and similarly for path2 and
        the file descriptor fd2. If the file descriptor was opened without O_SEARCH, the function shall check whether directory searches are permitted using
        the current permissions of the directory underlying the file descriptor. If the file descriptor was opened with O_SEARCH, the function shall not
        perform the check.</p>

        <p>Values for flag are constructed by a bitwise-inclusive OR of flags from the following list, defined in &lt;fcntl.h&gt;:</p>
      </blockquote><a name=""></a>

      <h4><a name="">AT_SYMLINK_FOLLOW</a></h4>

      <blockquote>
        If path1 names a symbolic link, a new link for the target of the symbolic link is created.
      </blockquote>

      <p>If <b>linkat</b>() is passed the special value AT_FDCWD in the fd1 or fd2 parameter, the current working directory shall be used for the respective
      path argument. If both fd1 and fd2 have value AT_FDCWD, the behavior shall be identical to a call to <b>link</b>(), except that symbolic links shall
      be handled as specified by the value of flag.</p>

      <blockquote>
        <p>Some implementations do allow links between file systems.</p>

        <p>If path1 refers to a symbolic link, application developers should use <b>linkat</b>() with appropriate flags to select whether or not the
        symbolic link should be resolved.</p>

        <p>If the AT_SYMLINK_FOLLOW flag is clear in the flag argument and the path1 argument names a symbolic link, a new link is created for the symbolic
        link path1 and not its target.</p>
      </blockquote><a name="3"></a>

      <h3><a name="3">RETURN VALUE</a></h3>

      <blockquote>
        Upon successful completion, these functions shall return 0. Otherwise, these functions shall return <b>-1</b> and set errno to indicate the error.
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLES</a></h3>

      <blockquote>
        Creating a Link to a File
        <pre>
   program demo_system_link
   use M_system, only : system_link, system_perror
   integer :: ierr
   ierr = system_link('myfile1','myfile2')
   if(ierr.ne.0)then
      call system_perror('*demo_system_link*')
   endif
   end program demo_system_link
<br />
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c120"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_mkdir(3f)</b> - [M_system] call <b>mkdir</b>(3c) to create a new directory <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="6">SYNOPSIS</a></h3><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        <p>Predefined variables are typically used to set permission modes. You can bytewise-OR together these variables to to create the most common
        permissions mode:</p>
        <pre>
    User:    R_USR  (read),  W_USR  (write),  X_USR(execute)
    Group:   R_GRP  (read),  W_GRP  (write),  X_GRP(execute)
    Others:  R_OTH  (read),  W_OTH  (write),  X_OTH(execute)
<br />
</pre>Additionally, some shortcuts are provided (basically a bitwise-OR combination of the above):
        <pre>
     Read + Write + Execute: RWX_U (User), RWX_G (Group), RWX_O (Others)
     DEFFILEMODE: Equivalent of 0666 =rw-rw-rw-
     ACCESSPERMS: Equivalent of 0777 = rwxrwxrwx
<br />
</pre>Therefore, to give only the user rwx (read+write+execute) rights whereas group members and others may not do anything, you can use any of the
following <b>mkdir</b>() calls equivalently:
        <pre>
     ierr= mkdir("mydir", IANY([R_USR, W_USR, X_USR]));
     ierr= mkdir("mydir", RWX_U);
<br />
</pre>In order to give anyone any rights (mode 0777 = rwxrwxrwx), you can use any of the following calls equivalently:
        <pre>
     ierr= mkdir("mydir",IANY([R_USR,W_USR,X_USR,R_GRP,W_GRP,X_GRP,R_OTH,W_OTH,X_OTH]));
     ierr= mkdir("mydir",IANY([RWX_U,RWX_G,RWX_O]));
     ierr= mkdir("mydir",ACCESSPERMS);
<br />
</pre>
      </blockquote><a name="3"></a>

      <h3><a name="3">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
   program demo_system_mkdir
   use M_system, only : system_perror
   use M_system, only : system_mkdir
   use M_system, only : R_GRP,R_OTH,R_USR,RWX_G,RWX_O
   use M_system, only : RWX_U,W_GRP,W_OTH,W_USR,X_GRP,X_OTH,X_USR
   use M_system, only : DEFFILEMODE, ACCESSPERMS
   implicit none
   integer :: ierr
   ierr=system_mkdir('_scratch',IANY([R_USR,W_USR,X_USR]))
   end program demo_system_mkdir
<br />
</pre>
      </blockquote><a name="4"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c123"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_mkfifo(3f)</b> - [M_system] make a FIFO special file relative to directory file descriptor <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="7">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
function <b>system_mkfifo</b>(pathname,mode) <b>result</b>(<i>ierr</i>)
<br />   character(len=*),intent(in)       :: pathname
   integer,intent(in)                :: mode
   integer :: ierr
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        A regular pipe can only connect two related processes. It is created by a process and will vanish when the last process closes it.

        <p>A named pipe, also called a FIFO for its behavior, can be used to connect two unrelated processes and exists independently of the processes;
        meaning it can exist even if no one is using it. A FIFO is created using the <b>mkfifo</b>() library function.</p>

        <p>The <b>mkfifo</b>() function creates a new FIFO special file named by the pathname.</p>

        <p>The file permission bits of the new FIFO are initialized from mode.</p>

        <p>The file permission bits of the mode argument are modified by the process' file creation mask.</p>

        <p>When bits in mode other than the file permission bits are set, the effect is implementation-defined.</p>

        <p>If path names a symbolic link, <b>mkfifo</b>() shall fail and set errno to [EEXIST].</p>

        <p>The FIFO's user ID will be set to the process' effective user ID.</p>

        <p>The FIFO's group ID shall be set to the group ID of the parent directory or to the effective group ID of the process.</p>

        <p>Implementations shall provide a way to initialize the FIFO's group ID to the group ID of the parent directory.</p>

        <p>Implementations may, but need not, provide an implementation-defined way to initialize the FIFO's group ID to the effective group ID of the
        calling process.</p>

        <p>Upon successful completion, <b>mkfifo</b>() shall mark for update the last data access, last data modification, and last file status change
        timestamps of the file.</p>

        <p>Also, the last data modification and last file status change timestamps of the directory that contains the new entry shall be marked for
        update.</p>

        <p>Predefined variables are typically used to set permission modes.</p>

        <p>You can bytewise-OR together these variables to to create the most common permissions mode:</p>
        <pre>
    User:    R_USR  (read),  W_USR  (write),  X_USR(execute)
    Group:   R_GRP  (read),  W_GRP  (write),  X_GRP(execute)
    Others:  R_OTH  (read),  W_OTH  (write),  X_OTH(execute)
<br />
</pre>Additionally, some shortcuts are provided (basically a bitwise-OR combination of the above):
        <pre>
     Read + Write + Execute: RWX_U (User), RWX_G (Group), RWX_O (Others)
     DEFFILEMODE: Equivalent of 0666 =rw-rw-rw-
     ACCESSPERMS: Equivalent of 0777 = rwxrwxrwx
<br />
</pre>Therefore, to give only the user rwx (read+write+execute) rights whereas group members and others may not do anything, you can use any of the
following <b>mkfifo</b>() calls equivalently:
        <pre>
     ierr= mkfifo("myfile", IANY([R_USR, W_USR, X_USR]));
     ierr= mkfifo("myfile", RWX_U);
<br />
</pre>In order to give anyone any rights (mode 0777 = rwxrwxrwx), you can use any of the following calls equivalently:
        <pre>
     ierr= mkfifo("myfile",IANY([R_USR,W_USR,X_USR,R_GRP,W_GRP,X_GRP,R_OTH,W_OTH,X_OTH]));
     ierr= mkfifo("myfile",IANY([RWX_U,RWX_G,RWX_O]));
     ierr= mkfifo("myfile",ACCESSPERMS);
</pre>
      </blockquote><a name="3"></a>

      <h3><a name="3">RETURN VALUE</a></h3>

      <blockquote>
        Upon successful completion, return 0. Otherwise, return <b>-1</b> and set errno to indicate the error. If <b>-1</b> is returned, no FIFO is created.
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLES</a></h3>

      <blockquote>
        The following example shows how to create a FIFO file named /home/cnd/mod_done, with read/write permissions for owner, and with read permissions for
        group and others.
        <pre>
   program demo_system_mkfifo
   use M_system, only : system_mkfifo, system_perror
   use M_system, only : R_GRP,R_OTH,R_USR,RWX_G,RWX_O
   use M_system, only : RWX_U,W_GRP,W_OTH,W_USR,X_GRP,X_OTH,X_USR
   use M_system, only : DEFFILEMODE, ACCESSPERMS
   implicit none
      integer :: status
      status = system_mkfifo("/tmp/buffer", IANY([W_USR, R_USR, R_GRP, R_OTH]))
      if(status.ne.0)then
         call system_perror('*mkfifo* error:')
      endif
   end program demo_system_mkfifo
<br />
</pre>Now some other process (or this one) can read from /tmp/buffer while this program is running or after, consuming the data as it is read.
      </blockquote><a name="5"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c126"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_opendir(3f)</b> - [M_system] open directory stream by calling <b>opendir</b>(3c) <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="11">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
subroutine <b>system_opendir</b>(dirname,dir,ierr)
<br />   character(len=*), intent(in) :: dirname
   type(c_ptr)                  :: dir
   integer,intent(out)          :: ierr
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>system_opendir</b>(3f) procedure opens a directory stream corresponding to the directory named by the dirname argument. The directory stream
        is positioned at the first entry.
      </blockquote><a name="3"></a>

      <h3><a name="3">RETURN VALUE</a></h3>

      <blockquote>
        Upon successful completion, a pointer to a C dir type is returned. Otherwise, these functions shall return a null pointer and set IERR to indicate
        the error.
      </blockquote><a name="4"></a>

      <h3><a name="4">ERRORS</a></h3>

      <blockquote>
        <p>An error corresponds to a condition described in <b>opendir</b>(3c):</p>

        <table cellpadding="3">
          <tr valign="top">
            <td class="c127" width="6%" nowrap="nowrap">EACCES</td>

            <td valign="bottom">Search permission is denied for the component of the path prefix of dirname or read permission is denied for dirname.</td>
          </tr>

          <tr valign="top">
            <td class="c127" width="6%" nowrap="nowrap">ELOOP</td>

            <td valign="bottom">A loop exists in symbolic links encountered during resolution of the dirname argument.</td>
          </tr>

          <tr valign="top">
            <td class="c127" colspan="2">ENAMETOOLONG</td>
          </tr>

          <tr valign="top">
            <td width="6%"></td>

            <td>The length of a component of a pathname is longer than {NAME_MAX}.</td>
          </tr>

          <tr valign="top">
            <td class="c127" width="6%" nowrap="nowrap">ENOENT</td>

            <td valign="bottom">A component of dirname does not name an existing directory or dirname is an empty string.</td>
          </tr>

          <tr valign="top">
            <td class="c127" colspan="2">ENOTDIR</td>
          </tr>

          <tr valign="top">
            <td width="6%"></td>

            <td>A component of dirname names an existing file that is neither a directory nor a symbolic link to a directory.</td>
          </tr>

          <tr valign="top">
            <td class="c127" width="6%" nowrap="nowrap">ELOOP</td>

            <td valign="bottom">More than {SYMLOOP_MAX} symbolic links were encountered during resolution of the dirname argument.</td>
          </tr>

          <tr valign="top">
            <td class="c127" width="6%" nowrap="nowrap">EMFILE</td>

            <td valign="bottom">All file descriptors available to the process are currently open.</td>
          </tr>

          <tr valign="top">
            <td class="c127" colspan="2">ENAMETOOLONG</td>
          </tr>

          <tr valign="top">
            <td width="6%"></td>

            <td>The length of a pathname exceeds {PATH_MAX}, or pathname resolution of a symbolic link produced an intermediate result with a length that
            exceeds {PATH_MAX}.</td>
          </tr>

          <tr valign="top">
            <td class="c127" width="6%" nowrap="nowrap">ENFILE</td>

            <td valign="bottom">Too many files are currently open in the system.</td>
          </tr>
        </table>
      </blockquote><a name="5"></a>

      <h3><a name="5">APPLICATION USAGE</a></h3>

      <blockquote>
        The <b>opendir</b>() function should be used in conjunction with <b>readdir</b>(), <b>closedir</b>(), and <b>rewinddir</b>() to examine the contents
        of the directory (see the EXAMPLES section in <b>readdir</b>()). This method is recommended for portability.
      </blockquote><a name="6"></a>

      <h3><a name="6">OPTIONS</a></h3>

      <blockquote>
        dirname name of directory to open a directory stream for
      </blockquote><a name="7"></a>

      <h3><a name="7">RETURNS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c127" width="6%" nowrap="nowrap">dir</td>

            <td valign="bottom">pointer to directory stream. If an error occurred, it will not be associated.</td>
          </tr>

          <tr valign="top">
            <td class="c127" width="6%" nowrap="nowrap">ierr</td>

            <td valign="bottom">0 indicates no error occurred</td>
          </tr>
        </table>
      </blockquote><a name="8"></a>

      <h3><a name="8">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
   program demo_system_opendir
   use M_system, only : system_opendir,system_readdir
   use M_system, only : system_closedir
   use iso_c_binding
   implicit none
   type(c_ptr)                  :: dir
   character(len=:),allocatable :: filename
   integer                      :: ierr
   !--- open directory stream to read from
   call system_opendir('.',dir,ierr)
   if(ierr.eq.0)then
      !--- read directory stream
      do
         call system_readdir(dir,filename,ierr)
         if(filename.eq.' ')exit
         write(*,*)filename
      enddo
   endif
   !--- close directory stream
   call system_closedir(dir,ierr)
   end program demo_system_opendir
</pre>
      </blockquote><a name="9"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c130"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_perm(3f)</b> - [M_system] get file type and permission as a string <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="7">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
function <b>system_perm</b>(<i>mode</i>) result (<i>perms</i>)
<br />   integer(kind=int64),intent(in)   :: MODE
   character(len=:),allocatable :: PERMS
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        <p>The <b>system_perm</b>(3f) function returns a string containing the type and permission of a file implied by the value of the <i>mode</i>
        value.</p>
      </blockquote><a name="3"></a>

      <h3><a name="3">RETURN VALUE</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c131" width="6%" nowrap="nowrap">PERMS</td>

            <td valign="bottom">returns the permission string in a format similar to that used by Unix commands such as <b>ls</b>(1).</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
   program demo_system_perm
   use M_system, only : system_perm, system_stat
   use,intrinsic     :: iso_fortran_env, only : int64
   implicit none
   character(len=4096) :: string
   integer(kind=int64)     :: values(13)
   integer             :: ierr
   character(len=:),allocatable :: perms
      values=0
      call get_command_argument(1, string)  ! get pathname from command line
      call system_stat(string,values,ierr)  ! get pathname information
      if(ierr.eq.0)then
         perms=system_perm(values(3))       ! convert permit mode to a string
         ! print permits as a string, decimal value, and octal value
         write(*,'("for ",a," permits[",a,"]",1x,i0,1x,o0)') &amp;
                 trim(string),perms,values(3),values(3)
      endif
   end program demo_system_perm
<br />
</pre>Results:
        <pre>
   demo_system_perm /tmp
<br />   for /tmp permits[drwxrwxrwx --S] 17407 41777
<br />
</pre>
      </blockquote><a name="5"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c134"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>perror(3f)</b> - [M_system] print error message for last C error on stderr <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="4">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
subroutine <b>system_perror</b>(<i>prefix</i>)
<br />      character(len=*),intent(in) :: prefix
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        Use <b>system_perror</b>(3f) to print an error message on stderr corresponding to the current value of the C global variable errno. Unless you use
        NULL as the argument <i>prefix</i>, the error message will begin with the <i>prefix</i> string, followed by a colon and a space (:). The remainder
        of the error message produced is one of the strings described for <b>strerror</b>(3c).
      </blockquote><a name="3"></a>

      <h3><a name="3">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
   program demo_system_perror
   use M_system, only : system_perror,system_rmdir
   implicit none
   character(len=:),allocatable :: DIRNAME
   DIRNAME='/NOT/THERE/OR/ANYWHERE'
   ! generate an error with a routine that supports errno and perror(3c)
   if(system_rmdir(DIRNAME).ne.0)then
      call system_perror('*demo_system_perror*:'//DIRNAME)
   endif
   write(*,'(a)')"That's all Folks!"
   end program demo_system_perror
<br />
</pre>Expected results:
        <pre>
   *demo_system_perror*:/NOT/THERE/OR/ANYWHERE: No such file or directory
   That's all Folks!
<br />
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c137"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_putenv(3f)</b> - [M_system:ENVIRONMENT] set environment variable from Fortran by calling <b>putenv</b>(3c) <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="7">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
subroutine <b>system_putenv</b>(<i>string</i>, <i>err</i>)
<br />    character(len=*),intent(in)    :: string
    integer, optional, intent(out) :: err
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>system_putenv</b>() function adds or changes the value of environment variables.
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c138" width="6%" nowrap="nowrap">string</td>

            <td valign="bottom"><i>string</i> of format "NAME=value". If name does not already exist in the environment, then <i>string</i> is added to the
            environment. If name does exist, then the value of name in the environment is changed to value. The <i>string</i> passed to <b>putenv</b>(3c)
            becomes part of the environment, so this routine creates a <i>string</i> each time it is called that increases the amount of memory the program
            uses.</td>
          </tr>

          <tr valign="top">
            <td class="c138" width="6%" nowrap="nowrap">err</td>

            <td valign="bottom">The <b>system_putenv</b>() function returns zero on success, or nonzero if an error occurs. A non-zero error usually
            indicates sufficient memory does not exist to store the variable.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLE</a></h3>

      <blockquote>
        Sample setting an environment variable from Fortran:
        <pre>
    program demo_system_putenv
    use M_system, only : system_putenv
    use iso_c_binding
    implicit none
    integer :: ierr
       !
       write(*,'(a)')'no environment variables containing "GRU":'
       call execute_command_line('env|grep GRU')
       !
       call system_putenv('GRU=this is the value',ierr)
       write(*,'(a,i0)')'now "GRU" should be defined: ',ierr
       call execute_command_line('env|grep GRU')
       !
       call system_putenv('GRU2=this is the second value',ierr)
       write(*,'(a,i0)')'now "GRU" and "GRU2" should be defined: ',ierr
       call execute_command_line('env|grep GRU')
       !
       call system_putenv('GRU2',ierr)
       call system_putenv('GRU',ierr)
       write(*,'(a,i0)')'should be gone, varies with different putenv(3c): ',ierr
       call execute_command_line('env|grep GRU')
       write(*,'(a)')'system_unsetenv(3f) is a better way to remove variables'
       !
    end program demo_system_putenv
<br />
</pre>Results:
        <pre>
   no environment variables containing "GRU":
   now "GRU" should be defined: 0
   GRU=this is the value
   now "GRU" and "GRU2" should be defined: 0
   GRU2=this is the second value
   GRU=this is the value
   should be gone, varies with different putenv(3c): 0
   system_unsetenv(3f) is a better way to remove variables
<br />
</pre>
      </blockquote><a name="5"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c140"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_readdir(3f)</b> - [M_system] read a directory using <b>readdir</b>(3c) <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="8">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
subroutine <b>system_readdir</b>(dir,filename,ierr)
<br /> type(c_ptr),value                         :: dir
 character(len=:),intent(out),allocatable  :: filename
 integer,intent(out)                       :: ierr
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        <p><b>system_readdir</b>(3f) returns the name of the directory entry at the current position in the directory stream specified by the argument DIR,
        and positions the directory stream at the next entry. It returns a null name upon reaching the end of the directory stream.</p>
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c141" width="6%" nowrap="nowrap">DIR</td>

            <td valign="bottom">A pointer to the directory opened by <b>system_opendir</b>(3f).</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">RETURNS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c141" colspan="2">FILENAME</td>
          </tr>

          <tr valign="top">
            <td width="6%"></td>

            <td>
              the name of the directory entry at the current position in the directory stream specified by the argument DIR, and positions the directory
              stream at the next entry.

              <p>The <b>readdir</b>() function does not return directory entries containing empty names. If entries for dot or dot-dot exist, one entry is
              returned for dot and one entry is returned for dot-dot.</p>

              <p>The entry is marked for update of the last data access timestamp each time it is read.</p>

              <p>reaching the end of the directory stream, the name is a blank name.</p>
            </td>
          </tr>

          <tr valign="top">
            <td class="c141" width="6%" nowrap="nowrap">IERR</td>

            <td valign="bottom">If IERR is set to non-zero on return, an error occurred.</td>
          </tr>
        </table>
      </blockquote><a name="5"></a>

      <h3><a name="5">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
   program demo_system_readdir
   use M_system, only : system_opendir,system_readdir
   use M_system, only : system_rewinddir,system_closedir
   use iso_c_binding
   implicit none
<br />   type(c_ptr)                  :: dir
   character(len=:),allocatable :: filename
   integer                      :: i, ierr
   !--- open directory stream to read from
   call system_opendir('.',dir,ierr)
   if(ierr.eq.0)then
      !--- read directory stream twice
      do i=1,2
         write(*,'(a,i0)')'PASS ',i
         do
            call system_readdir(dir,filename,ierr)
            if(filename.eq.' ')exit
            write(*,*)filename
         enddo
         call system_rewinddir(dir)
      enddo
   endif
   !--- close directory stream
   call system_closedir(dir,ierr)
<br />   end program demo_system_readdir
<br />
</pre>
      </blockquote><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c144"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_readenv(3f)</b> - [M_system:ENVIRONMENT] step thru and read environment table <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="7">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
function <b>system_readenv</b>() <b>result</b>(<i>string</i>)
<br />       character(len=:),allocatable  :: string
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        A simple interface allows reading the environment variable table of the process. Call <b>system_initenv</b>(3f) to initialize reading the
        environment table, then call <b>system_readenv</b>(3f) can be called until a blank line is returned. If more than one thread reads the environment
        or the environment is changed while being read the results are undefined.
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c145" width="6%" nowrap="nowrap">string</td>

            <td valign="bottom">the <i>string</i> returned from the environment of the form "NAME=VALUE"</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
   program demo_system_readenv
   use M_system, only : system_initenv, system_readenv
   character(len=:),allocatable :: string
      call system_initenv()
      do
         string=system_readenv()
         if(string.eq.'')then
            exit
         else
            write(*,'(a)')string
         endif
      enddo
   end program demo_system_readenv
<br />
</pre>Sample results:
        <pre>
   USERDOMAIN_ROAMINGPROFILE=buzz
   HOMEPATH=\Users\JSU
   APPDATA=C:\Users\JSU\AppData\Roaming
   MANPATH=/home/urbanjs/V600/LIBRARY/libGPF/download/tmp/man:/home/urbanjs/V600/doc/man:::
   DISPLAYNUM=0
   ProgramW6432=C:\Program Files
   HOSTNAME=buzz
   XKEYSYMDB=/usr/share/X11/XKeysymDB
   PUBLISH_CMD=
   OnlineServices=Online Services
        :
        :
        :
</pre>
      </blockquote><a name="5"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c147"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_realpath(3f)</b> - [M_system] call <b>realpath</b>(3c) to resolve a pathname <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="6">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
function <b>system_realpath</b>(<i>input</i>) <b>result</b>(<i>output</i>)
<br />       character(len=*),intent(in)  :: input
       character(len=:),allocatable :: output
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        <b>system_realpath</b>(3f) calls the C routine <b>realpath</b>(3c) to obtain the absolute pathname of given path
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c148" width="6%" nowrap="nowrap">INPUT</td>

            <td valign="bottom">pathname to resolve</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">RETURN VALUE</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c148" width="6%" nowrap="nowrap">OUTPUT</td>

            <td valign="bottom">The absolute pathname of the given <i>input</i> pathname. The pathname shall contain no components that are dot or dot-dot,
            or are symbolic links. It is equal to the NULL character if an error occurred.</td>
          </tr>
        </table>
      </blockquote><a name="5"></a>

      <h3><a name="5">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
   program demo_system_realpath
   use M_system, only : system_realpath, system_perror
   implicit none
   ! resolve each pathname given on command line
   character(len=:),allocatable :: pathi,patho
   integer                      :: i
   integer                      :: filename_length
      do i = 1, command_argument_count()
         ! get pathname from command line arguments
         call get_command_argument (i , length=filename_length)
         allocate(character(len=filename_length) :: pathi)
         call get_command_argument (i , value=pathi)
         !
         ! resolve each pathname
         patho=system_realpath(pathi)
         if(patho.ne.char(0))then
            write(*,*)trim(pathi),'=&gt;',trim(patho)
         else
            call system_perror('*system_realpath* error for pathname '//trim(pathi)//':')
            write(*,*)trim(pathi),'=&gt;',trim(patho)
         endif
         deallocate(pathi)
      enddo
      ! if there were no pathnames give resolve the pathname "."
      if(i.eq.1)then
         patho=system_realpath('.')
         write(*,*)'.=&gt;',trim(patho)
      endif
   end program demo_system_realpath
<br />
</pre>
      </blockquote>Example usage:
      <pre>
  demo_system_realpath
  .=&gt;/home/urbanjs/V600
<br />  cd /usr/share/man
  demo_system_realpath . .. NotThere
  .=&gt;/usr/share/man
  ..=&gt;/usr/share
  *system_realpath* error for pathname NotThere:: No such file or directory
  NotThere=&gt;NotThere
<br />
</pre>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c151"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_remove(3f)</b> - [M_system] call <b>remove</b>(3c) to remove file <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="6">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
function <b>system_remove</b>(<i>path</i>) <b>result</b>(<i>err</i>)
<br />   character(*),intent(in) :: path
   integer(c_int)          :: err
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        Fortran supports scratch files via the <b>OPEN</b>(3c) command; but does not otherwise allow for removing files. The <b>system_remove</b>(3f)
        command allows for removing files by name that the user has the authority to remove by calling the C <b>remove</b>(3c) function.
      </blockquote><a name="3"></a>

      <h3><a name="3">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
   program demo_system_remove
   use M_system, only : system_remove
   character(len=*),parameter :: FILE='MyJunkFile.txt'
   integer :: ierr
   write(*,*)'BEFORE CREATED '//FILE
   call execute_command_line('ls -l '//FILE)
   write(*,*)
<br />   ! note intentionally causes error if file exists
   open(unit=10,file=FILE,status='NEW')
   write(*,*)'AFTER OPENED '//FILE
   call execute_command_line('ls -l '//FILE)
   write(*,*)
<br />   write(10,'(a)') 'This is a file I want to delete'
   close(unit=10)
   write(*,*)'AFTER CLOSED '
   call execute_command_line('ls -l '//FILE)
   write(*,*)
<br />   ierr=system_remove(FILE)
   write(*,*)'AFTER REMOVED',IERR
   call execute_command_line('ls -l '//FILE)
   write(*,*)
<br />   end program demo_system_remove
<br />
</pre>Expected Results:
        <pre>
   &gt;  BEFORE CREATED MyJunkFile.txt
   &gt; ls: cannot access 'MyJunkFile.txt': No such file or directory
   &gt;
   &gt;  AFTER OPENED MyJunkFile.txt
   &gt; -rw-r--r-- 1 JSU None 0 Nov 19 19:32 MyJunkFile.txt
   &gt;
   &gt;  AFTER CLOSED
   &gt; -rw-r--r-- 1 JSU None 32 Nov 19 19:32 MyJunkFile.txt
   &gt;
   &gt;  AFTER REMOVED           0
   &gt; ls: cannot access 'MyJunkFile.txt': No such file or directory
<br />
</pre>
      </blockquote><a name="4"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c154"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_rename(3f)</b> - [M_system] call <b>rename</b>(3c) to rename a system file <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="8">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
function <b>system_rename</b>(input,output) <b>result</b>(<i>ierr</i>)
<br />   character(*),intent(in)    :: input,output
   integer                    :: ierr
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        Rename a file by calling <b>rename</b>(3c). It is not recommended that the rename occur while either filename is being used on a file currently
        <b>OPEN</b>(3f) by the program.

        <p>Both the old and new names must be on the same device.</p>
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c155" width="6%" nowrap="nowrap">INPUT</td>

            <td valign="bottom">system filename of an existing file to rename</td>
          </tr>

          <tr valign="top">
            <td class="c155" width="6%" nowrap="nowrap">OUTPUT</td>

            <td valign="bottom">system filename to be created or overwritten by INPUT file. Must be on the same device as the INPUT file.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">RETURNS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c155" width="6%" nowrap="nowrap">IERR</td>

            <td valign="bottom">zero (0) if no error occurs. If not zero a call to <b>system_errno</b>(3f) or <b>system_perror</b>(3f) is supported to
            diagnose error</td>
          </tr>
        </table>
      </blockquote><a name="5"></a>

      <h3><a name="5">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
     program demo_system_rename
     use M_system, only : system_rename
     use M_system, only : system_remove
     use M_system, only : system_perror
     implicit none
     character(len=256) :: string
     integer            :: ios, ierr
<br />     ! try to remove junk files just in case
     ierr=system_remove('_scratch_file_')
     write(*,'(a,i0)') 'should not be zero ',ierr
     call system_perror('*demo_system_rename*')
     ierr=system_remove('_renamed_scratch_file_')
     write(*,'(a,i0)') 'should not be zero ',ierr
     call system_perror('*demo_system_rename*')
<br />     ! create scratch file to rename
     open(unit=10,file='_scratch_file_',status='new')
     write(10,'(a)') 'Test by renaming "_scratch_file_" to "_renamed_scratch_file_"'
     write(10,'(a)') 'IF YOU SEE THIS ON OUTPUT THE RENAME WORKED'
     close(10)
     ! rename scratch file
     ierr=system_rename('_scratch_file_','_renamed_scratch_file_')
     if(ierr.ne.0)then
        write(*,*)'ERROR RENAMING FILE ',ierr
     endif
     ! read renamed file
     open(unit=11,file='_renamed_scratch_file_',status='old')
     INFINITE: do
        read(11,'(a)',iostat=ios)string
        if(ios.ne.0)exit INFINITE
        write(*,'(a)')trim(string)
     enddo INFINITE
     close(unit=11)
<br />     ! clean up
     ierr=system_remove('_scratch_file_')
     write(*,'(a,i0)') 'should not be zero ',ierr
     ierr=system_remove('_renamed_scratch_file_')
     write(*,'(a,i0)') 'should be zero ',ierr
<br />     end program demo_system_rename
<br />
</pre>
      </blockquote>Expected output:
      <pre>
   &gt; should not be zero -1
   &gt; *demo_system_rename*: No such file or directory
   &gt; should not be zero -1
   &gt; *demo_system_rename*: No such file or directory
   &gt; Test by renaming "_scratch_file_" to "_renamed_scratch_file_"
   &gt; IF YOU SEE THIS ON OUTPUT THE RENAME WORKED
   &gt; should not be zero -1
   &gt; should be zero 0
<br />
</pre><a name="6"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c158"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_rewinddir(3f)</b> - [M_system] call <b>rewinddir</b>(3c) to rewind directory stream <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="7">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
subroutine <b>system_rewinddir</b>(<i>dir</i>)
<br />    type(c_ptr),value :: dir
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        Return to pointer to the beginning of the list for a currently open directory list.
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c159" width="6%" nowrap="nowrap">DIR</td>

            <td valign="bottom">A C_pointer assumed to have been allocated by a call to <b>SYSTEM_OPENDIR</b>(3f).</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
   program demo_system_rewinddir
   use M_system, only : system_opendir,system_readdir
   use M_system, only : system_rewinddir,system_closedir
   use iso_c_binding
   implicit none
<br />   type(c_ptr)                  :: dir
   character(len=:),allocatable :: filename
   integer                      :: i, ierr
   !&gt;&gt;&gt; open directory stream to read from
   call system_opendir('.',dir,ierr)
   !&gt;&gt;&gt; read directory stream twice
   do i=1,2
      write(*,'(a,i0)')'PASS ',i
      do
         call system_readdir(dir,filename,ierr)
         if(filename.eq.' ')exit
         write(*,*)filename
      enddo
      !&gt;&gt;&gt; rewind directory stream
      call system_rewinddir(dir)
   enddo
   !&gt;&gt;&gt; close directory stream
   call system_closedir(dir,ierr)
<br />   end program demo_system_rewinddir
</pre>
      </blockquote><a name="5"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c162"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_rmdir(3f)</b> - [M_system] call <b>rmdir</b>(3c) to remove empty directories <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="6">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
function <b>system_rmdir</b>(<i>dirname</i>) <b>result</b>(<i>err</i>)
<br />    character(*),intent(in) :: dirname
    integer(c_int) :: err
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c163" colspan="2">DIRECTORY</td>
          </tr>

          <tr valign="top">
            <td width="6%"></td>

            <td>The name of a directory to remove if it is empty</td>
          </tr>

          <tr valign="top">
            <td class="c164" width="6%" nowrap="nowrap">err</td>

            <td valign="bottom">zero (0) if no error occurred</td>
          </tr>
        </table>
      </blockquote><a name="3"></a>

      <h3><a name="3">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
   program demo_system_rmdir
   use M_system, only : system_perror
   use M_system, only : system_rmdir, system_mkdir
   use M_system, only : RWX_U
   implicit none
   integer :: ierr
   write(*,*)'BEFORE TRY TO CREATE _scratch/'
   call execute_command_line('ls -ld _scratch')
<br />   write(*,*)'TRY TO CREATE _scratch/'
   ierr=system_mkdir('_scratch',RWX_U)
   write(*,*)'IERR=',ierr
   call execute_command_line('ls -ld _scratch')
<br />   write(*,*)'TRY TO REMOVE _scratch/'
   ierr=system_rmdir('_scratch')
   write(*,*)'IERR=',ierr
   call execute_command_line('ls -ld _scratch')
<br />   write(*,*)'TRY TO REMOVE _scratch when it should be gone/'
   ierr=system_rmdir('_scratch')
   call system_perror('*test of system_rmdir*')
   write(*,*)'IERR=',ierr
   call execute_command_line('ls -ld _scratch')
<br />   end program demo_system_rmdir
<br />
</pre>Expected output:
      </blockquote><a name="4"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c166"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_setsid(3f)</b> - [M_system:QUERY] create session and set the process group ID of a session leader <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="6">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
<b>integer</b>(kind=c_int) function <b>system_setsid</b>(<i>pid</i>)
<b>integer</b>(kind=c_int) :: <i>pid</i>
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c167" width="6%" nowrap="nowrap">The</td>

            <td valign="bottom"><b>setsid</b>() function creates a new session, if the calling process is not a process group leader. Upon return the</td>
          </tr>

          <tr valign="top">
            <td class="c167" colspan="2">calling process shall be the session leader of this new session, shall be the process</td>
          </tr>

          <tr valign="top">
            <td width="6%"></td>

            <td>group leader of a new process</td>
          </tr>

          <tr valign="top">
            <td class="c167" width="6%" nowrap="nowrap">group,</td>

            <td valign="bottom">and shall have no controlling terminal. The process group ID of the calling process shall be set equal to the</td>
          </tr>

          <tr valign="top">
            <td class="c167" colspan="2">process ID of the calling process. The calling process shall be the only process in the new process group</td>
          </tr>

          <tr valign="top">
            <td width="6%"></td>

            <td>and the only process in the new session.</td>
          </tr>
        </table>
      </blockquote><a name="3"></a>

      <h3><a name="3">RETURN VALUE</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c167" width="6%" nowrap="nowrap">Upon</td>

            <td valign="bottom">successful completion, <b>setsid</b>() shall return the value of the new process group ID of the calling process.
            Other&acirc;&euro; wise, it shall return &acirc;&circ;'1 and set errno to indicate the error.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">ERRORS</a></h3>

      <blockquote>
        The <b>setsid</b>() function shall fail if:

        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td width="3%">o</td>

              <td>The calling process is already a process group leader</td>
            </tr>

            <tr valign="top">
              <td width="3%">o</td>

              <td>the process group ID of a process other than the calling process matches the process ID of the calling process.</td>
            </tr>
          </table>
        </blockquote>
      </blockquote><a name="5"></a>

      <h3><a name="5">EXAMPLE</a></h3>

      <blockquote>
        Set SID from Fortran
        <pre>
   program demo_system_setsid
   use M_system,      only : system_setsid
   implicit none
      write(*,*)'SID=',system_setsid()
   end program demo_system_setsid
<br />
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c170"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_setumask(3f)</b> - [M_system] set the file mode creation umask <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="6">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
integer function <b>system_setumask</b>(<i>new_umask</i>) result (<i>old_umask</i>)
<br />    integer,intent(in)  :: new_umask
    integer(kind=c_int) :: umask_c
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>system_umask</b>(3f) function sets the file mode creation mask of the process to cmask and return the previous value of the mask. Only the
        file permission bits of cmask (see &lt;sys/stat.h&gt;) are used; the meaning of the other bits is implementation-defined.

        <p>The file mode creation mask of the process is used to turn off permission bits in the mode argument supplied during calls to the following
        functions:</p>

        <blockquote>
          <table cellpadding="3">
            <tr valign="top">
              <td class="c171" width="6%" nowrap="nowrap">*</td>

              <td valign="bottom"><b>open</b>(), <b>openat</b>(), <b>creat</b>(), <b>mkdir</b>(), <b>mkdirat</b>(), <b>mkfifo</b>(), and
              <b>mkfifoat</b>()</td>
            </tr>

            <tr valign="top">
              <td class="c171" width="6%" nowrap="nowrap">*</td>

              <td valign="bottom"><b>mknod</b>(), <b>mknodat</b>()</td>
            </tr>

            <tr valign="top">
              <td class="c171" width="6%" nowrap="nowrap">*</td>

              <td valign="bottom"><b>mq_open</b>()</td>
            </tr>

            <tr valign="top">
              <td class="c171" width="6%" nowrap="nowrap">*</td>

              <td valign="bottom"><b>sem_open</b>()</td>
            </tr>
          </table>
        </blockquote>

        <p>Bit positions that are set in cmask are cleared in the mode of the created file.</p>
      </blockquote><a name="3"></a>

      <h3><a name="3">RETURN VALUE</a></h3>

      <blockquote>
        The file permission bits in the value returned by <b>umask</b>() shall be the previous value of the file mode creation mask. The state of any other
        bits in that value is unspecified, except that a subsequent call to <b>umask</b>() with the returned value as cmask shall leave the state of the
        mask the same as its state before the first call, including any unspecified use of those bits.
      </blockquote><a name="4"></a>

      <h3><a name="4">ERRORS</a></h3>

      <blockquote>
        No errors are defined.
      </blockquote><a name="5"></a>

      <h3><a name="5">EXAMPLE</a></h3>

      <blockquote>
        Sample program
        <pre>
   program demo_setumask
   use M_system, only : system_getumask, system_setumask
   integer :: newmask
   integer :: i
   integer :: old_umask
   write(*,101)(system_getumask(),i=1,4)
   101 format(1x,i0,1x,"O'",o4.4,"'",1x,'Z"',z0,"'",1x,"B'",b12.12,"'")
   newmask=63
   old_umask=system_setumask(newmask)
   write(*,*)'NEW'
   write(*,101)(system_getumask(),i=1,4)
   end program demo_setumask
<br />
</pre>Expected output
        <pre>
    18 O'022' Z"12' B'000010010"
</pre>
      </blockquote><a name=""></a>

      <h4><a name="">NEW</a></h4>

      <blockquote>
        63 O'077' Z"3F' B'000111111"
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c174"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>SYSTEM_STAT</b> - [M_system] Get file status information <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="7">SYNTAX</a></h3>

      <blockquote>
        CALL <b>SYSTEM_STAT</b>(NAME, VALUES [, STATUS],[DEBUG])
        <pre>
   character(len=*),intent(in)          :: NAME
   integer(kind=int64),intent(out)      :: values(13)
   integer,optional,intent(out)         :: status
   integer,intent(in)                   :: debug
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        <p>This function returns information about a file. No permissions are required on the file itself, but execute (search) permission is required on
        all of the directories in path that lead to the file. The elements that are obtained and stored in the array VALUES:</p>
        <pre>
      VALUES(1) Device ID
      VALUES(2) Inode number
      VALUES(3) File mode
      VALUES(4) Number of links
      VALUES(5) Owner's uid
      VALUES(6) Owner's gid
      VALUES(7) ID of device containing directory entry for file (0 if not available)
      VALUES(8) File size (bytes)
      VALUES(9) Last access time as a Unix Epoch time rounded to seconds
      VALUES(10) Last modification time as a Unix Epoch time rounded to seconds
      VALUES(11) Last file status change time as a Unix Epoch time rounded to seconds
      VALUES(12) Preferred I/O block size (-1 if not available)
      VALUES(13) Number of blocks allocated (-1 if not available)
<br />
</pre>Not all these elements are relevant on all systems. If an element is not relevant, it is returned as 0.
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c175" width="6%" nowrap="nowrap">NAME</td>

            <td valign="bottom">The type shall be CHARACTER, of the default kind and a valid path within the file system.</td>
          </tr>

          <tr valign="top">
            <td class="c175" width="6%" nowrap="nowrap">VALUES</td>

            <td valign="bottom">The type shall be <b>INTEGER</b>(8), <b>DIMENSION</b>(13).</td>
          </tr>

          <tr valign="top">
            <td class="c175" width="6%" nowrap="nowrap">STATUS</td>

            <td valign="bottom">(Optional) status flag of type <b>INTEGER</b>(4). Returns 0 on success and a system specific error code otherwise.</td>
          </tr>

          <tr valign="top">
            <td class="c175" width="6%" nowrap="nowrap">DEBUG</td>

            <td valign="bottom">(Optional) print values being returned from C routine being called if value of 0 is used</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLE</a></h3>

      <blockquote>
        program demo_system_stat
        <pre>
   use M_system, only : system_stat, system_getpwuid, system_getgrgid
   use M_time, only :   fmtdate, u2d
   use, intrinsic :: iso_fortran_env, only : int32, int64
   implicit none
<br />   integer(kind=int64)  :: buff(13)
   integer(kind=int32)  :: status
   character(len=*),parameter :: fmt_date='year-month-day hour:minute:second'
<br />   integer(kind=int64) :: &amp;
      Device_ID,           Inode_number,          File_mode,                  Number_of_links,  Owner_uid,         &amp;
      Owner_gid,           Directory_device,      File_size,                  Last_access,      Last_modification, &amp;
      Last_status_change,  Preferred_block_size,  Number_of_blocks_allocated
   equivalence                                    &amp;
      ( buff(1)  , Device_ID                  ) , &amp;
      ( buff(2)  , Inode_number               ) , &amp;
      ( buff(3)  , File_mode                  ) , &amp;
      ( buff(4)  , Number_of_links            ) , &amp;
      ( buff(5)  , Owner_uid                  ) , &amp;
      ( buff(6)  , Owner_gid                  ) , &amp;
      ( buff(7)  , Directory_device           ) , &amp;
      ( buff(8)  , File_size                  ) , &amp;
      ( buff(9)  , Last_access                ) , &amp;
      ( buff(10) , Last_modification          ) , &amp;
      ( buff(11) , Last_status_change         ) , &amp;
      ( buff(12) , Preferred_block_size       ) , &amp;
      ( buff(13) , Number_of_blocks_allocated )
<br />   CALL SYSTEM_STAT("/etc/hosts", buff, status)
<br />   if (status == 0) then
      write (*, FMT="('Device ID(hex/decimal):',      T30, Z0,'h/',I0,'d')") buff(1),buff(1)
      write (*, FMT="('Inode number:',                T30, I0)") buff(2)
      write (*, FMT="('File mode (octal):',           T30, O19)") buff(3)
      write (*, FMT="('Number of links:',             T30, I0)") buff(4)
      write (*, FMT="('Owner''s uid/username:',       T30, I0,1x, A)") buff(5), system_getpwuid(buff(5))
      write (*, FMT="('Owner''s gid/group:',          T30, I0,1x, A)") buff(6), system_getgrgid(buff(6))
      write (*, FMT="('Device where located:',        T30, I0)") buff(7)
      write (*, FMT="('File size(bytes):',            T30, I0)") buff(8)
      write (*, FMT="('Last access time:',            T30, I0,1x, A)") buff(9), fmtdate(u2d(int(buff(9))),fmt_date)
      write (*, FMT="('Last modification time:',      T30, I0,1x, A)") buff(10),fmtdate(u2d(int(buff(10))),fmt_date)
      write (*, FMT="('Last status change time:',     T30, I0,1x, A)") buff(11),fmtdate(u2d(int(buff(11))),fmt_date)
      write (*, FMT="('Preferred block size(bytes):', T30, I0)") buff(12)
      write (*, FMT="('No. of blocks allocated:',     T30, I0)") buff(13)
   endif
<br />   end program demo_system_stat
<br />
</pre>Results:
        <pre>
   Device ID(hex/decimal):      3E6BE045h/1047257157d
   Inode number:                1407374886070599
   File mode (octal):                        100750
   Number of links:             1
   Owner's uid/username:        18 SYSTEM
   Owner's gid/group:           18 SYSTEM
   Device where located:        0
   File size(bytes):            824
   Last access time:            1557983191 2019-05-16 01:06:31
   Last modification time:      1557983191 2019-05-16 01:06:31
   Last status change time:     1557983532 2019-05-16 01:12:12
   Preferred block size(bytes): 65536
   No. of blocks allocated:     4
<br />
</pre>
      </blockquote><a name="5"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c182"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_uname(3f)</b> - [M_system] call a C wrapper that calls <b>uname</b>(3c) to get current system information from Fortran <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="6">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
subroutine <b>system_uname</b>(WHICH,NAMEOUT)
<br />    character(KIND=C_CHAR),intent(in) :: WHICH
    character(len=*),intent(out)      :: NAMEOUT
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        Given a letter, return a corresponding description of the current operating system. The NAMEOUT variable is assumed sufficiently large enough to
        hold the value.

        <table cellpadding="3">
          <tr valign="top">
            <td class="c183" width="6%" nowrap="nowrap">s</td>

            <td valign="bottom">return the kernel name</td>
          </tr>

          <tr valign="top">
            <td class="c183" width="6%" nowrap="nowrap">r</td>

            <td valign="bottom">return the kernel release</td>
          </tr>

          <tr valign="top">
            <td class="c183" width="6%" nowrap="nowrap">v</td>

            <td valign="bottom">return the kernel version</td>
          </tr>

          <tr valign="top">
            <td class="c183" width="6%" nowrap="nowrap">n</td>

            <td valign="bottom">return the network node hostname</td>
          </tr>

          <tr valign="top">
            <td class="c183" width="6%" nowrap="nowrap">m</td>

            <td valign="bottom">return the machine hardware name</td>
          </tr>

          <tr valign="top">
            <td class="c183" width="6%" nowrap="nowrap">T</td>

            <td valign="bottom">test mode -- print all information, in the following order - srvnm</td>
          </tr>
        </table>
      </blockquote><a name="3"></a>

      <h3><a name="3">EXAMPLE</a></h3>

      <blockquote>
        Call <b>uname</b>(3c) from Fortran
        <pre>
   program demo_system_uname
      use M_system, only : system_uname
      implicit none
      integer,parameter          :: is=100
      integer                    :: i
      character(len=*),parameter :: letters='srvnmxT'
      character(len=is)          :: string=' '
<br />      do i=1,len(letters)
         write(*,'(80("="))')
         call system_uname(letters(i:i),string)
         write(*,*)'=====&gt; TESTING system_uname('//letters(i:i)//')---&gt;'//trim(string)
      enddo
<br />   end program demo_system_uname
</pre>
      </blockquote><a name="4"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c186"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_unlink(3f)</b> - [M_system] remove a directory entry relative to directory file descriptor <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="5">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
integer function <b>unlink</b>(<i>path</i>);
<br />    character(len=*) :: path
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>unlink</b>() function shall remove a link to a file. If <i>path</i> names a symbolic link, <b>unlink</b>() shall remove the symbolic link
        named by <i>path</i> and shall not affect any file or directory named by the contents of the symbolic link. Otherwise, <b>unlink</b>() shall remove
        the link named by the pathname pointed to by <i>path</i> and shall decrement the link count of the file referenced by the link.

        <p>When the file's link count becomes 0 and no process has the file open, the space occupied by the file shall be freed and the file shall no longer
        be accessible. If one or more processes have the file open when the last link is removed, the link shall be removed before <b>unlink</b>() returns,
        but the removal of the file contents shall be postponed until all references to the file are closed.</p>

        <p>The <i>path</i> argument shall not name a directory unless the process has appropriate privileges and the implementation supports using
        <b>unlink</b>() on directories.</p>

        <p>Upon successful completion, <b>unlink</b>() shall mark for update the last data modification and last file status change timestamps of the parent
        directory. Also, if the file's link count is not 0, the last file status change timestamp of the file shall be marked for update.</p>

        <p>Values for flag are constructed by a bitwise-inclusive OR of flags from the following list, defined in &lt;fcntl.h&gt;:</p>
      </blockquote><a name=""></a>

      <h4><a name="">AT_REMOVEDIR</a></h4>

      <blockquote>
        <p>Remove the directory entry specified by fd and <i>path</i> as a directory, not a normal file.</p>
      </blockquote><a name="3"></a>

      <h3><a name="3">RETURN VALUE</a></h3>

      <blockquote>
        <p>Upon successful completion, these functions shall return 0. Otherwise, these functions shall return <b>-1</b> and set errno to indicate the
        error. If <b>-1</b> is returned, the named file shall not be changed.</p>
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLES</a></h3>

      <blockquote>
        Removing a link to a file
        <pre>
   program demo_system_unlink
   use M_system, only : system_unlink, system_perror
   integer :: ierr
   ierr = system_unlink('myfile1')
   if(ierr.ne.0)then
      call system_perror('*demo_system_unlink*')
   endif
   end program demo_system_unlink
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c189"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_unsetenv(3f)</b> - [M_system:ENVIRONMENT] delete an environment variable by calling <b>unsetenv</b>(3c) <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="7">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
subroutine <b>system_unsetenv</b>(name,ierr)
<br />   character(len=*),intent(in)  :: name
   integer,intent(out),optional :: ierr
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        <p>The <b>system_unsetenv</b>(3f) function deletes the variable name from the environment.</p>
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c190" width="6%" nowrap="nowrap">name</td>

            <td valign="bottom">name of variable to delete. If name does not exist in the environment, then the function succeeds, and the environment is
            unchanged.</td>
          </tr>

          <tr valign="top">
            <td class="c190" width="6%" nowrap="nowrap">ierr</td>

            <td valign="bottom">The <b>system_unsetenv</b>(3f) function returns zero on success, or <b>-1</b> on error. name is NULL, points to a string of
            length 0, or contains an '=' character. Insufficient memory to add a new variable to the environment.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">EXAMPLE</a></h3>

      <blockquote>
        Sample program:
        <pre>
     program demo_system_unsetenv
     use M_system, only : system_unsetenv, system_putenv
     implicit none
     call system_putenv('GRU=this is the value')
     write(*,'(a)')'The variable GRU should be set'
     call execute_command_line('env|grep GRU')
     call system_unsetenv('GRU')
     write(*,'(a)')'The variable GRU should not be set'
     call execute_command_line('env|grep GRU')
     end program demo_system_unsetenv
<br />
</pre>
      </blockquote><a name="5"></a>
    </div>
  </div>
</div>
<?
<div><P style="page-break-before: always">
  <div id="Container">
    <div id="Content">
      <div class="c193"></div><a name="0"></a>

      <h3><a name="0">NAME</a></h3>

      <blockquote>
        <b>system_utime(3f)</b> - [M_system] set file access and modification times <b>(LICENSE:PD)</b>
      </blockquote><a name="contents" id="contents"></a>

      <h3><a name="7">SYNOPSIS</a></h3>

      <blockquote>
        <pre>
function <b>utime</b>(pathname,times)
<br />        character(len=*),intent(in) :: pathname
        integer,intent(in),optional :: times(2)
        logical                     :: utime
<br />
</pre>
      </blockquote><a name="2"></a>

      <h3><a name="2">DESCRIPTION</a></h3>

      <blockquote>
        The <b>system_utime</b>(3f) function sets the access and modification times of the file named by the path argument by calling <b>utime</b>(3c).

        <p>If <b>times</b>() is not present the access and modification times of the file shall be set to the current time.</p>

        <p>To use <b>system_utime</b>(3f) the effective user ID of the process must match the owner of the file, or the process has to have write permission
        to the file or has appropriate privileges,</p>
      </blockquote><a name="3"></a>

      <h3><a name="3">OPTIONS</a></h3>

      <blockquote>
        <table cellpadding="3">
          <tr valign="top">
            <td class="c194" width="6%" nowrap="nowrap">times</td>

            <td valign="bottom">If present, the values will be interpreted as the access and modification times as Unix Epoch values. That is, they are
            times measured in seconds since the Unix Epoch.</td>
          </tr>

          <tr valign="top">
            <td class="c194" colspan="2">pathname</td>
          </tr>

          <tr valign="top">
            <td width="6%"></td>

            <td>name of the file whose access and modification times are to be updated.</td>
          </tr>
        </table>
      </blockquote><a name="4"></a>

      <h3><a name="4">RETURN VALUE</a></h3>

      <blockquote>
        Upon successful completion .TRUE. is returned. Otherwise, and the file times remain unaffected.
      </blockquote><a name="5"></a>

      <h3><a name="5">ERRORS</a></h3>

      <blockquote>
        The underlying <b>utime</b>(3c) function fails if:

        <table cellpadding="3">
          <tr valign="top">
            <td class="c194" width="6%" nowrap="nowrap">EACCES</td>

            <td valign="bottom">Search permission is denied by a component of the path prefix; or the times argument is a null pointer and the effective
            user ID of the process does not match the owner of the file, the process does not have write permission for the file, and the process does not
            have appropriate privileges.</td>
          </tr>

          <tr valign="top">
            <td class="c194" width="6%" nowrap="nowrap">ELOOP</td>

            <td valign="bottom">A loop exists in symbolic links encountered during resolution of the path argument.</td>
          </tr>

          <tr valign="top">
            <td class="c194" colspan="2">ENAMETOOLONG</td>
          </tr>

          <tr valign="top">
            <td width="6%"></td>

            <td>The length of a component of a pathname is longer than {NAME_MAX}.</td>
          </tr>

          <tr valign="top">
            <td class="c194" width="6%" nowrap="nowrap">ENOENT</td>

            <td valign="bottom">A component of path does not name an existing file or path is an empty string.</td>
          </tr>

          <tr valign="top">
            <td class="c194" colspan="2">ENOTDIR</td>
          </tr>

          <tr valign="top">
            <td width="6%"></td>

            <td>A component of the path prefix names an existing file that is neither a directory nor a symbolic link to a directory, or the path argument
            contains at least one non-&lt;slash&gt; character and ends with one or more trailing &lt;slash&gt; characters and the last pathname component
            names an existing file that is neither a directory nor a symbolic link to a directory.</td>
          </tr>

          <tr valign="top">
            <td class="c194" width="6%" nowrap="nowrap">EPERM</td>

            <td valign="bottom">The times argument is not a null pointer and the effective user ID of the calling process does not match the owner of the
            file and the calling process does not have appropriate privileges.</td>
          </tr>

          <tr valign="top">
            <td class="c194" width="6%" nowrap="nowrap">EROFS</td>

            <td valign="bottom">The file system containing the file is read-only.</td>
          </tr>
        </table>
      </blockquote>

      <p>The <b>utime</b>() function may fail if:</p>
      <pre>
       ELOOP  More than {SYMLOOP_MAX} symbolic links were encountered
              during resolution of the path argument.
<br />       ENAMETOOLONG  The length of a pathname exceeds {PATH_MAX}, or
                     pathname resolution of a symbolic link produced
                     an intermediate result with a length that exceeds
                     {PATH_MAX}.
<br />
</pre><a name="6"></a>

      <h3><a name="6">EXAMPLES</a></h3>

      <blockquote>
        Sample program
        <pre>
      program demo_system_utime
      use M_system, only : system_utime, system_perror
      use M_time, only   : d2u
      implicit none
      character(len=4096) :: pathname
      integer             :: times(2)
      integer             :: i
         do i=1,command_argument_count()
            call get_command_argument(i, pathname)
            if(.not.system_utime(pathname,times))then
               call system_perror('*demo_system_utime*')
            endif
         enddo
      end program demo_system_utime
<br />
</pre>
      </blockquote>
      <hr />
    </div>
  </div>
</div>
</article>
</body>
</html>
